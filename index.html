<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AZX minigame</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #00e5ff; --green: #00c853; --warn: #ffab00; }
        body { font-family: sans-serif; background: var(--bg); color: #fff; padding: 20px; display: flex; flex-direction: column; align-items: center; }
        
        /* Layout */
        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; align-items: flex-start; margin-top: 20px;}
        
        /* Left: Image */
        .image-box { position: relative; border: 2px solid #333; display: none; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }

        /* Right: Controls */
        .controls { width: 320px; background: var(--panel); padding: 20px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        
        .status { color: #aaa; margin-bottom: 15px; font-style: italic; min-height: 1.2em; }
        
        /* The Big Button */
        .btn { width: 100%; padding: 15px; border: none; border-radius: 6px; font-weight: bold; cursor: pointer; font-size: 16px; margin-bottom: 10px; transition: 0.2s; }
        .btn-green { background: var(--green); color: white; }
        .btn-green:hover { background: #009624; transform: scale(1.02); }
        .btn-green:disabled { background: #444; color: #888; cursor: not-allowed; transform: none; }
        
        .btn-small { padding: 5px 10px; font-size: 12px; background: #333; color: #aaa; margin-top: 20px; }

        /* Training Modal */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal-content { background: #222; padding: 30px; border-radius: 10px; text-align: center; width: 300px; border: 1px solid #444; }
        .train-img { transform: scale(3); image-rendering: pixelated; margin: 20px 0; border: 1px solid #555; }
        .train-input { font-size: 30px; width: 60px; text-align: center; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }

        /* Grid Display (Mini) */
        .grid-mini { display: grid; grid-template-columns: repeat(10, 1fr); gap: 1px; background: #333; margin-top: 15px; border: 1px solid #444; }
        .cell-mini { width: 100%; height: 20px; text-align: center; font-size: 10px; background: #222; border: none; color: #888; }
        .cell-mini.active { color: white; font-weight: bold; }
    </style>
</head>
<body>

    <h2 style="color:var(--accent)">Doro</h2>
    <div style="color:#777; font-size: 0.9em;">Paste Image (Ctrl+V) &bull; Teach numbers once &bull; Solve instantly</div>

    <div class="container">
        <!-- The Screenshot -->
        <div class="image-box" id="imgBox">
            <canvas id="gameCanvas"></canvas>
            <canvas id="overlayCanvas"></canvas>
        </div>

        <!-- The Sidebar -->
        <div class="controls">
            <div id="status" class="status">Waiting for paste...</div>
            
            <button id="actionBtn" class="btn btn-green" disabled onclick="confirmMove()">
                WAITING FOR IMAGE
            </button>

            <!-- Debug Grid to see what the computer "thinks" the numbers are -->
            <div id="miniGrid" class="grid-mini"></div>

            <button class="btn btn-small" onclick="clearMemory()">âš  Reset Learned Numbers</button>
        </div>
    </div>

    <!-- The "Teach Me" Popup -->
    <div id="trainModal" class="modal">
        <div class="modal-content">
            <h3 style="margin-top:0">Unknown Shape</h3>
            <p>I don't know this number yet.<br>What is it?</p>
            <canvas id="trainCanvas" class="train-img"></canvas>
            <br><br>
            <input type="number" id="trainInput" class="train-input" min="0" max="9" autofocus>
            <br><br>
            <button class="btn btn-green" onclick="submitTraining()">Save & Continue</button>
            <br>
            <small style="color:#777; cursor:pointer" onclick="skipTraining()">Skip/Blank</small>
        </div>
    </div>

<script>
    // --- SETTINGS ---
    const COLS = 10;
    const ROWS = 15;
    const THRESHOLD = 200; // Brightness threshold (0-255). Lower if numbers are dark.
    // ----------------

    // State
    let gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let cellSignatures = Array(ROWS).fill().map(() => Array(COLS).fill(null));
    let templateLibrary = JSON.parse(localStorage.getItem('sum10_templates')) || {};
    let unknownQueue = []; // Queue for training
    let currentBestMove = null;

    // --- PASTE HANDLER ---
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => processImage(img);
            }
        }
    });

    function processImage(img) {
        document.getElementById('imgBox').style.display = 'block';
        document.getElementById('status').innerText = "Analyzing pixels...";
        
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlayCanvas');
        
        // Resize
        canvas.width = img.width; canvas.height = img.height;
        overlay.width = img.width; overlay.height = img.height;
        ctx.drawImage(img, 0, 0);

        const cellW = img.width / COLS;
        const cellH = img.height / ROWS;

        // Reset Data
        gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        cellSignatures = Array(ROWS).fill().map(() => Array(COLS).fill(null));
        unknownQueue = [];

        // Build Mini Grid UI
        const miniGrid = document.getElementById('miniGrid');
        miniGrid.innerHTML = '';
        
        // 1. SCAN GRID & GENERATE SIGNATURES
        for(let r=0; r<ROWS; r++){
            for(let c=0; c<COLS; c++){
                
                // Create Input for Mini Grid
                let cellInput = document.createElement('input');
                cellInput.className = 'cell-mini';
                cellInput.id = `mini-${r}-${c}`;
                cellInput.readOnly = true;
                miniGrid.appendChild(cellInput);

                // Get Cell Image Data
                // We crop 20% off edges to ignore grid lines/borders
                const padX = cellW * 0.2; 
                const padY = cellH * 0.2;
                
                const imgData = ctx.getImageData(
                    (c*cellW)+padX, (r*cellH)+padY, 
                    cellW-(padX*2), cellH-(padY*2)
                );
                
                // Create a "Signature" (Hash) of the image
                // We turn it into High Contrast Black/White string
                const sig = getSignature(imgData);
                cellSignatures[r][c] = sig;

                // Check Memory
                if (templateLibrary[sig] !== undefined) {
                    gridData[r][c] = templateLibrary[sig];
                    cellInput.value = templateLibrary[sig] || '';
                    if(templateLibrary[sig] > 0) cellInput.classList.add('active');
                } else {
                    // It's a non-empty looking cell but we don't know the number
                    if(sig.length > 10) { // If sig length is tiny, it's likely a blank cell
                        // Check if we already queued this exact shape
                        if (!unknownQueue.find(q => q.sig === sig)) {
                            unknownQueue.push({ sig, r, c, w: cellW, h: cellH });
                        }
                    } else {
                        // It's blank
                        templateLibrary[sig] = 0; 
                    }
                }
            }
        }

        // 2. HANDLE RESULTS
        if (unknownQueue.length > 0) {
            startTraining();
        } else {
            solveBoard();
        }
    }

    // --- IMAGE PROCESSING ---
    function getSignature(imgData) {
        let binaryString = "";
        const d = imgData.data;
        let hasContent = false;
        
        // Simple downsampling: Skip pixels to make hash smaller/faster
        // and convert to 1 (Bright) or 0 (Dark)
        for (let i = 0; i < d.length; i += 4 * 2) { // Step by 2 pixels
            const r=d[i], g=d[i+1], b=d[i+2];
            const bright = (r+g+b)/3;
            if (bright > THRESHOLD) {
                binaryString += "1";
                hasContent = true;
            } else {
                binaryString += "0";
            }
        }
        return hasContent ? binaryString : "empty";
    }

    // --- TRAINING MODE ---
    let trainingIndex = 0;
    
    function startTraining() {
        trainingIndex = 0;
        showTrainingModal();
    }

    function showTrainingModal() {
        if (trainingIndex >= unknownQueue.length) {
            // Done training
            document.getElementById('trainModal').style.display = 'none';
            localStorage.setItem('sum10_templates', JSON.stringify(templateLibrary));
            
            // Refill grid data based on new knowledge
            for(let r=0; r<ROWS; r++){
                for(let c=0; c<COLS; c++){
                    const sig = cellSignatures[r][c];
                    if(templateLibrary[sig] !== undefined) {
                        gridData[r][c] = templateLibrary[sig];
                        const input = document.getElementById(`mini-${r}-${c}`);
                        input.value = templateLibrary[sig] || '';
                        if(templateLibrary[sig]) input.classList.add('active');
                    }
                }
            }
            solveBoard();
            return;
        }

        const item = unknownQueue[trainingIndex];
        const modal = document.getElementById('trainModal');
        const canvas = document.getElementById('trainCanvas');
        const input = document.getElementById('trainInput');
        
        modal.style.display = 'flex';
        
        // Draw the unknown shape onto the modal canvas
        canvas.width = item.w;
        canvas.height = item.h;
        const mainCtx = document.getElementById('gameCanvas').getContext('2d');
        // We grab from main canvas again to show user
        // Note: we grab full cell for visibility
        canvas.getContext('2d').drawImage(
            document.getElementById('gameCanvas'),
            item.c * item.w, item.r * item.h, item.w, item.h,
            0, 0, item.w, item.h
        );
        
        input.value = '';
        input.focus();
    }

    function submitTraining() {
        const val = parseInt(document.getElementById('trainInput').value);
        if (isNaN(val)) return; // Must be number
        
        const currentSig = unknownQueue[trainingIndex].sig;
        templateLibrary[currentSig] = val;
        
        trainingIndex++;
        showTrainingModal();
    }

    function skipTraining() {
        const currentSig = unknownQueue[trainingIndex].sig;
        templateLibrary[currentSig] = 0; // Mark as blank/garbage
        trainingIndex++;
        showTrainingModal();
    }
    
    // Enter key support for modal
    document.getElementById('trainInput').addEventListener("keypress", function(event) {
        if (event.key === "Enter") submitTraining();
    });

    // --- SOLVER LOGIC ---
    function solveBoard() {
        const ctx = document.getElementById('overlayCanvas').getContext('2d');
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
        let bestMatch = null;
        let bestScore = -1;

        // Find greedy best match
        for (let r1 = 0; r1 < ROWS; r1++) {
            for (let c1 = 0; c1 < COLS; c1++) {
                for (let r2 = r1; r2 < ROWS; r2++) {
                    for (let c2 = c1; c2 < COLS; c2++) {
                        
                        let sum = 0;
                        let count = 0;
                        
                        for(let i=r1; i<=r2; i++){
                            for(let j=c1; j<=c2; j++){
                                let v = gridData[i][j];
                                sum += v;
                                if(v > 0) count++;
                            }
                        }

                        if(sum === 10 && count > 0) {
                            // Score: Count is King. Break ties with Area.
                            let score = (count * 100) + ((r2-r1+1)*(c2-c1+1));
                            
                            if(score > bestScore) {
                                bestScore = score;
                                bestMatch = { r1, c1, r2, c2, count };
                            }
                        }
                    }
                }
            }
        }

        currentBestMove = bestMatch;
        const btn = document.getElementById('actionBtn');

        if (bestMatch) {
            highlightMove(bestMatch);
            document.getElementById('status').innerText = `Ready! Best move clears ${bestMatch.count} numbers.`;
            btn.innerHTML = `MATCH DONE<br><span style='font-size:0.7em; font-weight:normal'>Click to find next</span>`;
            btn.disabled = false;
        } else {
            document.getElementById('status').innerText = "No moves left.";
            btn.innerText = "NO MOVES FOUND";
            btn.disabled = true;
        }
    }

    function highlightMove(m) {
        const canvas = document.getElementById('overlayCanvas');
        const ctx = canvas.getContext('2d');
        const cellW = canvas.width / COLS;
        const cellH = canvas.height / ROWS;

        const x = m.c1 * cellW;
        const y = m.r1 * cellH;
        const w = (m.c2 - m.c1 + 1) * cellW;
        const h = (m.r2 - m.r1 + 1) * cellH;

        ctx.fillStyle = "rgba(0, 255, 0, 0.4)";
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 4;
        ctx.fillRect(x, y, w, h);
        ctx.strokeRect(x, y, w, h);
    }

    function confirmMove() {
        if(!currentBestMove) return;
        
        // Clear cells in data
        const m = currentBestMove;
        for(let r=m.r1; r<=m.r2; r++){
            for(let c=m.c1; c<=m.c2; c++){
                gridData[r][c] = 0;
                document.getElementById(`mini-${r}-${c}`).value = '';
                document.getElementById(`mini-${r}-${c}`).classList.remove('active');
            }
        }
        
        // Find next
        solveBoard();
    }

    function clearMemory() {
        if(confirm("Are you sure? You will have to teach it the numbers again.")) {
            localStorage.removeItem('sum10_templates');
            templateLibrary = {};
            location.reload();
        }
    }
</script>
</body>
</html>
