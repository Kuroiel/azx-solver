<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>azx mini game</title>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        :root { --bg: #1e1e24; --panel: #2b2b36; --accent: #00bcd4; --green: #4caf50; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: #fff; display: flex; flex-direction: column; align-items: center; padding: 20px; margin: 0;}
        
        h1 { margin: 10px 0; color: var(--accent); }
        p { color: #aaa; margin-bottom: 20px; font-size: 0.9em; }
        
        .main-layout { display: flex; gap: 20px; align-items: flex-start; flex-wrap: wrap; justify-content: center; }

        /* Left Side: The Image */
        .image-panel { position: relative; border: 4px solid #444; border-radius: 4px; overflow: hidden;}
        canvas { display: block; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }

        /* Right Side: The Grid & Controls */
        .control-panel { background: var(--panel); padding: 20px; border-radius: 8px; width: 360px; box-shadow: 0 10px 30px rgba(0,0,0,0.5); }
        
        /* The Grid of Inputs */
        .grid-container {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10 Columns */
            gap: 2px;
            background: #000;
            padding: 2px;
            margin-bottom: 20px;
            border: 1px solid #555;
        }
        .cell-input {
            width: 100%;
            height: 25px;
            text-align: center;
            background: #333;
            color: white;
            border: none;
            font-size: 14px;
            font-weight: bold;
        }
        .cell-input:focus { background: var(--accent); color: #000; outline: none; }
        /* Highlight class for the best move */
        .highlight-cell { background: var(--green) !important; color: white !important; }

        /* Big Action Button */
        .action-btn {
            width: 100%;
            padding: 15px;
            font-size: 18px;
            font-weight: bold;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background: var(--green);
            color: white;
            transition: 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .action-btn:hover { background: #43a047; transform: translateY(-2px); }
        .action-btn:disabled { background: #555; transform: none; cursor: not-allowed; }
        .btn-subtext { font-size: 12px; font-weight: normal; opacity: 0.8; }

        .status-text { margin-top: 10px; text-align: center; color: #aaa; font-style: italic; min-height: 20px; }
        
        .recalc-note { font-size: 0.8em; color: #777; margin-top: 10px; text-align: center; }
    </style>
</head>
<body>

    <h1>Sum-10 Assistant</h1>
    <p>1. Paste Screenshot (Ctrl+V) &nbsp;|&nbsp; 2. Verify Numbers &nbsp;|&nbsp; 3. Follow the Green Highlight</p>

    <div class="main-layout">
        
        <!-- Visual Reference -->
        <div class="image-panel" id="canvasWrapper" style="display:none">
            <canvas id="gameCanvas"></canvas>
            <canvas id="overlayCanvas"></canvas>
        </div>

        <!-- Interactive Board -->
        <div class="control-panel">
            <div id="gridEditor" class="grid-container">
                <!-- Inputs generated by JS -->
            </div>

            <button id="nextMoveBtn" class="action-btn" onclick="confirmMove()" disabled>
                <span>MATCH DONE</span>
                <span class="btn-subtext">Click to find next</span>
            </button>
            
            <div id="status" class="status-text">Paste image to start...</div>
            <div class="recalc-note">Tip: You can manually change numbers in the grid above if the scan was wrong.</div>
        </div>
    </div>

<script>
    // --- CONFIG ---
    const COLS = 10; 
    const ROWS = 15;
    // --------------

    let gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let currentBestMove = null; // Stores {r1,c1, r2,c2}
    
    // Setup Grid UI immediately
    const gridEditor = document.getElementById('gridEditor');
    for(let r=0; r<ROWS; r++){
        for(let c=0; c<COLS; c++){
            let input = document.createElement('input');
            input.type = 'text';
            input.className = 'cell-input';
            input.id = `cell-${r}-${c}`;
            input.maxLength = 1;
            
            // If user manually changes a number, update data and recalculate
            input.oninput = (e) => {
                let val = parseInt(e.target.value);
                if(isNaN(val)) val = 0;
                gridData[r][c] = val;
                findAndShowBestMove(); // Live update
            };
            gridEditor.appendChild(input);
        }
    }

    // PASTE HANDLER
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => processImage(img);
            }
        }
    });

    async function processImage(img) {
        document.getElementById('canvasWrapper').style.display = 'block';
        document.getElementById('status').innerText = "Processing Image...";
        document.getElementById('nextMoveBtn').disabled = true;

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlayCanvas');
        
        canvas.width = img.width;
        canvas.height = img.height;
        overlay.width = img.width;
        overlay.height = img.height;
        ctx.drawImage(img, 0, 0);

        const cellW = img.width / COLS;
        const cellH = img.height / ROWS;

        const worker = await Tesseract.createWorker('eng');
        await worker.setParameters({
            tessedit_char_whitelist: '0123456789',
            tessedit_pageseg_mode: Tesseract.PSM.SINGLE_CHAR,
        });

        // Scan Grid
        let processed = 0;
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                // Crop
                const cCanv = document.createElement('canvas');
                cCanv.width = cellW; cCanv.height = cellH;
                const cCtx = cCanv.getContext('2d');
                
                const padX = cellW * 0.2;
                const padY = cellH * 0.2;
                cCtx.drawImage(canvas, c*cellW+padX, r*cellH+padY, cellW-padX*2, cellH-padY*2, 0, 0, cellW, cellH);

                const { data: { text } } = await worker.recognize(cCanv);
                let val = parseInt(text.trim()) || 0;
                
                // Update Data
                gridData[r][c] = val;
                
                // Update UI
                const input = document.getElementById(`cell-${r}-${c}`);
                input.value = val === 0 ? '' : val;
                
                processed++;
                if(processed % 10 === 0) document.getElementById('status').innerText = `Scanning: ${Math.round(processed/(ROWS*COLS)*100)}%`;
            }
        }

        await worker.terminate();
        document.getElementById('status').innerText = "Scan Complete. Highlighting best move...";
        document.getElementById('nextMoveBtn').disabled = false;
        
        findAndShowBestMove();
    }

    function findAndShowBestMove() {
        // Reset highlights
        document.querySelectorAll('.highlight-cell').forEach(el => el.classList.remove('highlight-cell'));
        const ctx = document.getElementById('overlayCanvas').getContext('2d');
        ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);

        let bestMatch = null;
        let bestScore = -1; // Higher is better

        // 1. Find all matches
        for (let r1 = 0; r1 < ROWS; r1++) {
            for (let c1 = 0; c1 < COLS; c1++) {
                for (let r2 = r1; r2 < ROWS; r2++) {
                    for (let c2 = c1; c2 < COLS; c2++) {
                        
                        let sum = 0;
                        let count = 0;
                        
                        // Sum rectangle
                        for(let i=r1; i<=r2; i++){
                            for(let j=c1; j<=c2; j++){
                                let v = gridData[i][j];
                                sum += v;
                                if(v > 0) count++;
                            }
                        }

                        if(sum === 10 && count > 0) {
                            // SCORING LOGIC
                            // We want High Count (clearing 5 numbers is better than 2)
                            // Secondary is Area (larger area might clear distinct blanks)
                            let score = (count * 1000) + ((r2-r1+1)*(c2-c1+1));
                            
                            if(score > bestScore) {
                                bestScore = score;
                                bestMatch = { r1, c1, r2, c2, count };
                            }
                        }
                    }
                }
            }
        }

        currentBestMove = bestMatch;

        if (bestMatch) {
            highlightMove(bestMatch);
            document.getElementById('status').innerText = `Best Move: Clears ${bestMatch.count} numbers!`;
            document.getElementById('nextMoveBtn').disabled = false;
        } else {
            document.getElementById('status').innerText = "No moves left that sum to 10.";
            document.getElementById('nextMoveBtn').disabled = true;
        }
    }

    function highlightMove(m) {
        // 1. Highlight Inputs
        for(let r=m.r1; r<=m.r2; r++){
            for(let c=m.c1; c<=m.c2; c++){
                document.getElementById(`cell-${r}-${c}`).classList.add('highlight-cell');
            }
        }

        // 2. Draw on Overlay
        const canvas = document.getElementById('overlayCanvas');
        const ctx = canvas.getContext('2d');
        const cellW = canvas.width / COLS;
        const cellH = canvas.height / ROWS;

        const x = m.c1 * cellW;
        const y = m.r1 * cellH;
        const w = (m.c2 - m.c1 + 1) * cellW;
        const h = (m.r2 - m.r1 + 1) * cellH;

        ctx.fillStyle = "rgba(76, 175, 80, 0.5)";
        ctx.strokeStyle = "#00ff00";
        ctx.lineWidth = 4;
        ctx.fillRect(x, y, w, h);
        ctx.strokeRect(x, y, w, h);
    }

    function confirmMove() {
        if(!currentBestMove) return;

        // Clear data in grid
        const m = currentBestMove;
        for(let r=m.r1; r<=m.r2; r++){
            for(let c=m.c1; c<=m.c2; c++){
                gridData[r][c] = 0;
                document.getElementById(`cell-${r}-${c}`).value = "";
            }
        }

        // Find next
        findAndShowBestMove();
    }
</script>
</body>
</html>
