<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sum-10 Strategic Solver</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #00e5ff; --gold: #ffd740; --green: #69f0ae; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: #e0e0e0; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        
        /* Layout: Row-Reverse puts the panel on the Left, Stage on Right */
        .layout { display: flex; flex-direction: row-reverse; gap: 20px; flex-wrap: wrap-reverse; justify-content: center; align-items: flex-start; }
        
        /* Interactive Stage */
        .stage { position: relative; border: 2px solid #444; background: #000; cursor: crosshair; }
        canvas { display: block; image-rendering: pixelated; }
        #overlayCanvas { position: absolute; top: 0; left: 0; }
        
        /* Controls */
        .panel { width: 300px; background: var(--panel); padding: 20px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.5); display: flex; flex-direction: column; }
        .status { font-weight: bold; margin-bottom: 15px; color: var(--accent); min-height: 1.2em; font-size: 0.9em; border-bottom: 1px solid #333; padding-bottom: 10px; }
        
        .btn { width: 100%; padding: 20px; border: none; border-radius: 4px; font-weight: bold; font-size: 18px; cursor: pointer; background: #333; color: #777; transition: 0.1s; margin-top: 10px;}
        .btn.active { background: var(--green); color: #000; box-shadow: 0 0 15px rgba(105, 240, 174, 0.4); animation: pulse 1.5s infinite; }
        .btn:active { transform: translateY(2px); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; animation: none; }

        @keyframes pulse { 0% { box-shadow: 0 0 0 0 rgba(105, 240, 174, 0.7); } 70% { box-shadow: 0 0 0 10px rgba(105, 240, 174, 0); } 100% { box-shadow: 0 0 0 0 rgba(105, 240, 174, 0); } }

        .slider-box { margin: 15px 0; padding: 10px; background: #2a2a2a; border-radius: 4px; border: 1px solid #333; }
        .slider-header { display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa; margin-bottom: 5px; }

        .info-text { font-size: 0.8em; color: #aaa; margin-top: 20px; text-align: center; line-height: 1.5; }
        .highlight { color: var(--green); font-weight: bold; }

        /* Correction Tooltip */
        .tooltip { position: absolute; background: rgba(0,0,0,0.95); padding: 15px; border: 1px solid #fff; border-radius: 6px; pointer-events: none; display: none; transform: translate(-50%, -100%); margin-top: -15px; text-align: center; z-index: 100; box-shadow: 0 5px 15px black;}
        .tooltip-img { width: 48px; height: 48px; border: 1px solid #555; display: block; margin: 0 auto 10px; image-rendering: pixelated; }
        .tooltip-hint { color: var(--gold); font-size: 12px; margin-top: 5px; }
    </style>
</head>
<body>

    <h2 style="color:var(--accent); margin-top:0;">sprinters stakes</h2>
    
    <div class="layout">
        <div class="stage" id="stageContainer">
            <canvas id="mainCanvas"></canvas>
            <canvas id="overlayCanvas"></canvas>
            <div id="correctionTooltip" class="tooltip">
                <canvas id="tooltipCanvas" class="tooltip-img"></canvas>
                <div>Type Correct Number</div>
                <div class="tooltip-hint">(Press 'X' to delete)</div>
            </div>
        </div>

        <div class="panel">
            <div id="status" class="status">Paste screenshot (Ctrl+V)</div>

            <div class="slider-box">
                <div class="slider-header"><span>Filter Sensitivity</span> <span id="threshVal">180</span></div>
                <input type="range" id="threshold" min="100" max="250" value="180" style="width:100%" oninput="process()">
            </div>

            <button id="solveBtn" class="btn" disabled onclick="applyMove()">MOVE DONE</button>
            
            <div class="info-text">
                Strategy: <b>Look-Ahead AI</b><br>
                It may pick a smaller move now to unlock a massive move next.<br><br>
                1. Do <span class="highlight">Green Box</span> move.<br>
                2. Click <span class="highlight">MOVE DONE</span>.<br>
            </div>
            
            <div style="margin-top:auto; text-align:center; font-size:0.7em; color:#555; cursor:pointer;" onclick="resetMem()">
                [ Clear Learned Data ]
            </div>
        </div>
    </div>

<script>
    // --- CONFIG ---
    const ROWS = 15;
    const COLS = 10;
    const NORM_SIZE = 16;
    
    // --- ASCII HEURISTICS ---
    const ASCII_DIGITS = {
        1: ["  #  "," ##  ","  #  ","  #  ","  #  ","  #  "," ### "],
        2: [" ### ","#   #","    #","   # ","  #  "," #   ","#####"],
        3: ["#####","    #","   # ","    #","    #","#   #"," ### "],
        4: ["   # ","  ## "," # # ","#  # ","#####","   # ","   # "],
        5: ["#####","#    ","#### ","    #","    #","#   #"," ### "],
        6: [" ### ","#    ","#    ","#### ","#   #","#   #"," ### "],
        7: ["#####","    #","   # ","  #  "," #   "," #   "," #   "],
        8: [" ### ","#   #"," ### ","#   #","#   #","#   #"," ### "],
        9: [" ### ","#   #","#   #"," ####","    #","   # "," ### "],
        0: [" ### ","#   #","#   #","#   #","#   #","#   #"," ### "]
    };

    // --- STATE ---
    let srcImg = null;
    let gridData = [];
    let blobs = [];
    let currentMove = null;
    let userMemory = JSON.parse(localStorage.getItem('sum10_focus_mem')) || [];
    let systemMemory = [];

    // --- INIT ---
    generateSystemMemory();
    
    // --- EVENTS ---
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => { srcImg = img; process(); };
            }
        }
    });

    const stage = document.getElementById('stageContainer');
    const tooltip = document.getElementById('correctionTooltip');
    let correctionTarget = null; 

    stage.addEventListener('mousedown', e => {
        if(!srcImg) return;
        const rect = stage.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        const clicked = blobs.find(b => 
            x >= b.x - 5 && x <= b.x + b.w + 5 && 
            y >= b.y - 15 && y <= b.y + b.h + 5
        );

        if(clicked) {
            correctionTarget = clicked;
            tooltip.style.display = 'block';
            tooltip.style.left = (clicked.x + clicked.w/2) + 'px';
            tooltip.style.top = clicked.y + 'px';
            
            const tc = document.getElementById('tooltipCanvas');
            tc.width = NORM_SIZE; tc.height = NORM_SIZE;
            const tctx = tc.getContext('2d');
            const img = tctx.createImageData(NORM_SIZE, NORM_SIZE);
            for(let i=0; i<clicked.feature.length; i++) {
                const v = clicked.feature[i]*255;
                img.data[i*4]=v; img.data[i*4+1]=v; img.data[i*4+2]=v; img.data[i*4+3]=255;
            }
            tctx.putImageData(img,0,0);
            e.stopPropagation();
        } else {
            tooltip.style.display = 'none';
            correctionTarget = null;
        }
    });

    window.addEventListener('keydown', e => {
        if(correctionTarget && e.key >= '0' && e.key <= '9') {
            const num = parseInt(e.key);
            userMemory.push({ label: num, data: correctionTarget.feature });
            localStorage.setItem('sum10_focus_mem', JSON.stringify(userMemory));
            tooltip.style.display = 'none';
            correctionTarget = null;
            process(); 
        }
        if(correctionTarget && (e.key.toLowerCase() === 'x' || e.key === 'Delete')) {
             userMemory.push({ label: -1, data: correctionTarget.feature });
             localStorage.setItem('sum10_focus_mem', JSON.stringify(userMemory));
             tooltip.style.display = 'none';
             correctionTarget = null;
             process();
        }
    });

    // --- PROCESS ---
    function process() {
        if(!srcImg) return;
        
        const thresh = parseInt(document.getElementById('threshold').value);
        document.getElementById('threshVal').innerText = thresh;

        const cvs = document.getElementById('mainCanvas');
        const ctx = cvs.getContext('2d');
        const ovl = document.getElementById('overlayCanvas');
        
        cvs.width = srcImg.width; cvs.height = srcImg.height;
        ovl.width = srcImg.width; ovl.height = srcImg.height;

        ctx.drawImage(srcImg, 0, 0);

        const raw = ctx.getImageData(0,0,cvs.width,cvs.height);
        blobs = detectBlobs(raw, cvs.width, cvs.height, thresh);
        gridData = mapBlobsToGrid(blobs);

        blobs.forEach(b => {
            if(b.gridR === null) return;
            b.feature = extractFeature(ctx, b);
            
            let match = findBestMatch(b.feature, userMemory);
            if(!match) match = findBestMatch(b.feature, systemMemory, 50);

            if(match) {
                if(match.label !== -1) {
                    gridData[b.gridR][b.gridC] = match.label;
                    b.label = match.label;
                } else {
                    b.isGarbage = true;
                }
            } else {
                const forced = findBestMatch(b.feature, systemMemory, Infinity);
                gridData[b.gridR][b.gridC] = forced.label;
                b.label = forced.label;
                b.lowConf = true;
            }
        });

        calculateStrategicMove();
    }

    // --- AI STRATEGY ENGINE (Depth-1 Lookahead) ---
    function calculateStrategicMove() {
        // 1. Get all currently available moves
        const currentMoves = getAllMoves(gridData);
        
        if (currentMoves.length === 0) {
            currentMove = null;
            drawScene();
            return;
        }

        // Optimization: If there are too many moves, only lookahead for the top X largest ones
        // to prevent browser freeze.
        const candidates = currentMoves.slice(0, 15); // Check top 15 moves deeply

        let bestStrategy = null;
        let maxTotalPoints = -1;

        // 2. Simulate each candidate move
        for (let move of candidates) {
            // A. Create a hypothetical board state
            const simGrid = cloneGrid(gridData);
            
            // B. Apply this move to simulation
            applyMoveToGrid(simGrid, move);
            
            // C. Find the best move on the NEW board (The "Next Step")
            const nextMoves = getAllMoves(simGrid);
            const bestNext = nextMoves.length > 0 ? nextMoves[0] : null;
            
            // D. Calculate Score
            // Score = Current Move Count + (Next Move Count * 0.9)
            // We weigh the next move slightly less to prioritize immediate points slightly
            const nextScore = bestNext ? bestNext.count : 0;
            const totalScore = move.count + nextScore;

            if (totalScore > maxTotalPoints) {
                maxTotalPoints = totalScore;
                bestStrategy = move;
                // Store the predicted next score for UI logic if needed
                bestStrategy.predictedNext = nextScore;
            }
        }

        currentMove = bestStrategy;
        drawScene();
    }

    function getAllMoves(grid) {
        let moves = [];
        for (let r1=0; r1<ROWS; r1++) {
            for (let c1=0; c1<COLS; c1++) {
                for (let r2=r1; r2<ROWS; r2++) {
                    for (let c2=c1; c2<COLS; c2++) {
                        let sum=0, count=0;
                        for(let i=r1; i<=r2; i++){
                            for(let j=c1; j<=c2; j++){
                                let v = grid[i][j];
                                sum+=v; if(v>0) count++;
                            }
                        }
                        if(sum === 10 && count > 0) {
                            moves.push({
                                r1, c1, r2, c2, count,
                                area: (r2-r1+1)*(c2-c1+1)
                            });
                        }
                    }
                }
            }
        }
        // Sort by Count Descending
        return moves.sort((a, b) => b.count - a.count);
    }

    function cloneGrid(grid) {
        return grid.map(row => [...row]);
    }

    function applyMoveToGrid(grid, move) {
        for(let r=move.r1; r<=move.r2; r++) {
            for(let c=move.c1; c<=move.c2; c++) {
                grid[r][c] = 0;
            }
        }
    }

    // --- DRAWING ---
    function drawScene() {
        const cvs = document.getElementById('overlayCanvas');
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0,0,cvs.width,cvs.height);

        // 1. Draw Labels (or Blackout if cleared)
        blobs.forEach(b => {
            if(b.isGarbage || !b.label) return;
            
            // Check if this cell is cleared in gridData
            if (gridData[b.gridR][b.gridC] === 0) {
                // DRAW BLACKOUT
                ctx.fillStyle = "black";
                ctx.fillRect(b.x, b.y, b.w, b.h);
                return; // Stop drawing label
            }

            // Draw Label
            const labelX = b.x - 2;
            const labelY = b.y - 12;
            const size = 14;

            ctx.fillStyle = b.lowConf ? "#ffd740" : "#69f0ae"; 
            ctx.beginPath();
            ctx.roundRect(labelX, labelY, size, size, 2);
            ctx.fill();

            ctx.font = "bold 11px Arial";
            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(b.label, labelX + size/2, labelY + size/2 + 1);
        });

        // 2. Draw Best Move
        const btn = document.getElementById('solveBtn');
        if(currentMove) {
            btn.disabled = false;
            btn.className = "btn active";
            
            let statusText = `Best Move: Clears ${currentMove.count}.`;
            if(currentMove.predictedNext > 0) {
                statusText += ` (Unlocks match of ${currentMove.predictedNext})`;
            }
            
            btn.innerHTML = `MOVE DONE<br><span style="font-size:0.6em; font-weight:normal">${statusText}</span>`;
            document.getElementById('status').innerText = statusText;

            let minX=9999, maxX=0, minY=9999, maxY=0;
            let found = false;
            
            blobs.forEach(b => {
                if(b.gridR >= currentMove.r1 && b.gridR <= currentMove.r2 && 
                   b.gridC >= currentMove.c1 && b.gridC <= currentMove.c2 && !b.isGarbage) {
                    if(b.x<minX)minX=b.x; if(b.x+b.w>maxX)maxX=b.x+b.w;
                    if(b.y<minY)minY=b.y; if(b.y+b.h>maxY)maxY=b.y+b.h;
                    found=true;
                }
            });

            if(found) {
                const pad = 6;
                ctx.strokeStyle = "#69f0ae"; 
                ctx.lineWidth = 4;
                ctx.strokeRect(minX-pad, minY-pad, (maxX-minX)+pad*2, (maxY-minY)+pad*2);
                
                ctx.fillStyle = "rgba(105, 240, 174, 0.25)";
                ctx.fillRect(minX-pad, minY-pad, (maxX-minX)+pad*2, (maxY-minY)+pad*2);
            }
        } else {
            btn.disabled = true;
            btn.className = "btn";
            btn.innerHTML = "NO MOVES FOUND";
            document.getElementById('status').innerText = "Board cleared or no moves left.";
        }
    }

    function applyMove() {
        if(!currentMove) return;
        applyMoveToGrid(gridData, currentMove);
        calculateStrategicMove();
    }

    // --- UTILS ---
    function detectBlobs(imgData, w, h, t) {
        const d=imgData.data, v=new Uint8Array(w*h), res=[];
        for(let i=0; i<w*h; i++) {
            if(v[i])continue;
            if((d[i*4]+d[i*4+1]+d[i*4+2])/3 > t) {
                let s=[i], minX=w, maxX=0, minY=h, maxY=0; v[i]=1;
                while(s.length){
                    const c=s.pop(), cx=c%w, cy=Math.floor(c/w);
                    if(cx<minX)minX=cx; if(cx>maxX)maxX=cx; if(cy<minY)minY=cy; if(cy>maxY)maxY=cy;
                    [c+1,c-1,c+w,c-w].forEach(n=>{
                        if(n>=0 && n<w*h && !v[n] && (d[n*4]+d[n*4+1]+d[n*4+2])/3 > t){v[n]=1;s.push(n);}
                    });
                }
                const width=maxX-minX+1, height=maxY-minY+1;
                if(width>3 && height>6 && width<60 && height<60) res.push({x:minX, y:minY, w:width, h:height});
            }
        }
        return res;
    }

    function extractFeature(ctx, b) {
        const c=document.createElement('canvas'); c.width=NORM_SIZE; c.height=NORM_SIZE;
        const x=c.getContext('2d'); x.drawImage(ctx.canvas,b.x,b.y,b.w,b.h,0,0,NORM_SIZE,NORM_SIZE);
        const d=x.getImageData(0,0,NORM_SIZE,NORM_SIZE).data, a=[];
        for(let i=0; i<d.length; i+=4) a.push(d[i]>100?1:0);
        return a;
    }

    function findBestMatch(f, lib, maxErr=30) {
        let best=null, min=Infinity;
        lib.forEach(l=>{
            let e=0; for(let i=0;i<256;i++)if(f[i]!==l.data[i])e++;
            if(e<min){min=e; best=l;}
        });
        return min<=maxErr ? best : null;
    }

    function mapBlobsToGrid(blobs) {
        let g=Array(ROWS).fill().map(()=>Array(COLS).fill(0));
        if(!blobs.length) return g;
        let minX=9999, maxX=0, minY=9999, maxY=0;
        blobs.forEach(b=>{if(b.x<minX)minX=b.x; if(b.x+b.w>maxX)maxX=b.x+b.w; if(b.y<minY)minY=b.y; if(b.y+b.h>maxY)maxY=b.y+b.h;});
        const tW=maxX-minX, tH=maxY-minY, cW=tW/9.5, cH=tH/14.5;
        blobs.forEach(b=>{
            const cx=b.x+b.w/2, cy=b.y+b.h/2;
            const c=Math.round((cx-minX)/(tW/9)), r=Math.round((cy-minY)/(tH/14));
            if(c>=0 && c<COLS && r>=0 && r<ROWS) { b.gridR=r; b.gridC=c; } else { b.gridR=null; }
        });
        return g;
    }

    function generateSystemMemory() {
        for(let n in ASCII_DIGITS) {
            const art=ASCII_DIGITS[n], f=new Array(256).fill(0);
            for(let r=0;r<16;r++) for(let c=0;c<16;c++) {
                const ar=Math.floor(r/(16/7)), ac=Math.floor(c/(16/5));
                if(art[ar] && art[ar][ac]==='#') f[r*16+c]=1;
            }
            systemMemory.push({label:parseInt(n), data:f});
        }
    }

    function resetMem() {
        if(confirm("Clear memory?")) { localStorage.removeItem('sum10_focus_mem'); userMemory=[]; process(); }
    }
</script>
</body>
</html>
