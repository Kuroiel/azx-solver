<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sum-10 Auto-Detector</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #00bcd4; --green: #4caf50; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: #fff; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        
        h2 { color: var(--accent); margin-bottom: 5px; }
        .instructions { color: #888; font-size: 0.9em; margin-bottom: 20px; text-align: center; }

        .layout { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; align-items: flex-start; }

        /* Left: The Image Stage */
        .stage { position: relative; border: 2px solid #333; min-width: 300px; min-height: 200px; background: #000; display: flex; justify-content: center; align-items: center; }
        .stage canvas { display: block; max-width: 100%; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        .placeholder { color: #555; pointer-events: none; }

        /* Right: Controls */
        .panel { background: var(--panel); padding: 20px; border-radius: 8px; width: 320px; }
        
        .btn { width: 100%; padding: 12px; font-size: 16px; font-weight: bold; border: none; border-radius: 4px; cursor: pointer; margin-top: 10px; transition: 0.2s; }
        .btn-green { background: var(--green); color: white; }
        .btn-green:hover { background: #43a047; }
        .btn-green:disabled { background: #333; color: #666; cursor: default; }

        .slider-group { margin-bottom: 15px; }
        .slider-group label { display: flex; justify-content: space-between; font-size: 0.85em; color: #aaa; margin-bottom: 5px; }
        input[type=range] { width: 100%; }

        /* Training Modal */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 999; }
        .modal-box { background: #222; padding: 30px; border-radius: 12px; text-align: center; border: 1px solid #444; }
        .train-view { transform: scale(4); margin: 20px; border: 1px solid #666; image-rendering: pixelated; }
        .train-input { font-size: 24px; width: 50px; text-align: center; padding: 5px; background: #333; color: white; border: 1px solid #555; border-radius: 4px; }
    </style>
</head>
<body>

    <h2>AZX minigame</h2>
    <div class="instructions">Paste Screenshot (Ctrl+V).<br>If numbers aren't detecting, adjust the "Brightness Threshold".</div>

    <div class="layout">
        <div class="stage" id="stage">
            <span class="placeholder">Paste Image Here</span>
            <canvas id="imgCanvas" style="display:none"></canvas>
            <canvas id="overlayCanvas"></canvas>
        </div>

        <div class="panel">
            <div class="slider-group">
                <label>Brightness Threshold <span id="threshVal">150</span></label>
                <input type="range" id="threshold" min="50" max="250" value="150" oninput="reprocess()">
            </div>

            <div id="status" style="color: #ffd700; min-height: 1.2em; font-size: 0.9em;">Waiting...</div>

            <button id="solveBtn" class="btn btn-green" disabled onclick="confirmMove()">
                SOLVE
            </button>
            
            <div style="margin-top: 20px; font-size: 0.8em; color: #666; text-align: center; cursor: pointer;" onclick="clearData()">
                [ Reset Learned Numbers ]
            </div>
        </div>
    </div>

    <!-- Training Modal -->
    <div id="trainModal" class="modal">
        <div class="modal-box">
            <h3 style="margin:0 0 10px 0;">New Number Shape</h3>
            <p style="color:#aaa; font-size:0.9em;">What number is this?</p>
            <canvas id="trainCanvas" class="train-view"></canvas>
            <br>
            <input type="number" id="trainInput" class="train-input" min="0" max="9">
            <br><br>
            <button class="btn btn-green" onclick="saveTraining()">Save</button>
        </div>
    </div>

<script>
    // CONSTANTS
    const ROWS = 15;
    const COLS = 10;
    
    // STATE
    let srcImage = null;
    let gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let blobs = []; // Holds the detected number coordinates
    let templates = JSON.parse(localStorage.getItem('sum10_blobs')) || {};
    let trainingQueue = [];
    let currentMove = null;

    // --- PASTE HANDLER ---
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => { srcImage = img; reprocess(); };
            }
        }
    });

    // --- MAIN PIPELINE ---
    function reprocess() {
        if(!srcImage) return;
        document.querySelector('.placeholder').style.display = 'none';
        document.getElementById('imgCanvas').style.display = 'block';

        const thresh = parseInt(document.getElementById('threshold').value);
        document.getElementById('threshVal').innerText = thresh;

        // 1. Draw Image
        const canvas = document.getElementById('imgCanvas');
        const overlay = document.getElementById('overlayCanvas');
        canvas.width = srcImage.width; canvas.height = srcImage.height;
        overlay.width = srcImage.width; overlay.height = srcImage.height;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(srcImage, 0, 0);

        // 2. Find Blobs (The Numbers)
        const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);
        blobs = detectBlobs(imgData, thresh);

        // 3. Map Blobs to Grid
        gridData = mapBlobsToGrid(blobs, canvas.width, canvas.height);

        // 4. Identify Numbers (or Queue for training)
        trainingQueue = [];
        identifyNumbers();

        // 5. Update UI
        drawDebugOverlay();

        if (trainingQueue.length > 0) {
            document.getElementById('status').innerText = `New shapes found! Training needed.`;
            startTraining();
        } else {
            solve();
        }
    }

    // --- BLOB DETECTION ALGORITHM (Flood Fill) ---
    function detectBlobs(imgData, threshold) {
        const w = imgData.width;
        const h = imgData.height;
        const d = imgData.data;
        const visited = new Uint8Array(w * h);
        const foundBlobs = [];

        // Stack-based flood fill to avoid recursion limits
        const stack = []; 

        for (let y = 0; y < h; y+=2) { // Skip every other row for speed
            for (let x = 0; x < w; x+=2) {
                const idx = (y * w + x);
                if (visited[idx]) continue;

                // Simple brightness check
                const r=d[idx*4], g=d[idx*4+1], b=d[idx*4+2];
                if ((r+g+b)/3 > threshold) {
                    
                    // Found a bright pixel, start flood fill
                    let minX=x, maxX=x, minY=y, maxY=y;
                    stack.push(idx);
                    visited[idx] = 1;

                    while(stack.length > 0) {
                        const curr = stack.pop();
                        const cy = Math.floor(curr / w);
                        const cx = curr % w;

                        if (cx < minX) minX = cx;
                        if (cx > maxX) maxX = cx;
                        if (cy < minY) minY = cy;
                        if (cy > maxY) maxY = cy;

                        // Check neighbors (4-way)
                        const neighbors = [curr-1, curr+1, curr-w, curr+w];
                        for(let n of neighbors) {
                            if (n >= 0 && n < visited.length && visited[n] === 0) {
                                const nr=d[n*4], ng=d[n*4+1], nb=d[n*4+2];
                                // If neighbor is also bright
                                if ((nr+ng+nb)/3 > threshold) {
                                    visited[n] = 1;
                                    stack.push(n);
                                }
                            }
                        }
                    }

                    // Filter Noise
                    const width = maxX - minX;
                    const height = maxY - minY;
                    // Must be reasonable size to be a number
                    if (width > 4 && height > 8 && width < 100 && height < 100) {
                        foundBlobs.push({ x: minX, y: minY, w: width, h: height });
                    }
                }
            }
        }
        return foundBlobs;
    }

    // --- MAP COORDINATES TO 10x15 GRID ---
    function mapBlobsToGrid(rawBlobs, imgW, imgH) {
        let newGrid = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        
        if (rawBlobs.length === 0) return newGrid;

        // Find bounds of the "Game Board" based on blobs
        let minX=imgW, maxX=0, minY=imgH, maxY=0;
        rawBlobs.forEach(b => {
            if(b.x < minX) minX = b.x;
            if(b.x + b.w > maxX) maxX = b.x + b.w;
            if(b.y < minY) minY = b.y;
            if(b.y + b.h > maxY) maxY = b.y + b.h;
        });

        // Add a tiny buffer
        const boardW = maxX - minX;
        const boardH = maxY - minY;
        const cellW = boardW / COLS;
        const cellH = boardH / ROWS;

        rawBlobs.forEach(b => {
            const centerX = b.x + b.w/2;
            const centerY = b.y + b.h/2;

            // Calculate grid index relative to board bounds
            const c = Math.floor((centerX - minX) / cellW);
            const r = Math.floor((centerY - minY) / cellH);

            if(r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                // Attach grid info to blob for later use
                b.gridR = r;
                b.gridC = c;
            }
        });
        
        return newGrid; // We fill values in next step
    }

    // --- IDENTIFY & MATCHING ---
    function identifyNumbers() {
        const ctx = document.getElementById('imgCanvas').getContext('2d');

        blobs.forEach(b => {
            if(b.gridR === undefined) return; // Blob outside grid logic

            // Extract Pixel Data of just this blob
            // We resize to 20x20 for consistent comparison
            const tempC = document.createElement('canvas');
            tempC.width = 20; tempC.height = 20;
            const tCtx = tempC.getContext('2d');
            
            tCtx.drawImage(document.getElementById('imgCanvas'), 
                b.x, b.y, b.w, b.h, 
                0, 0, 20, 20
            );

            // Create Hash (Signature)
            const sig = createSignature(tCtx.getImageData(0,0,20,20));
            b.signature = sig;

            if (templates[sig] !== undefined) {
                // Known number
                gridData[b.gridR][b.gridC] = templates[sig];
            } else {
                // Unknown
                trainingQueue.push(b);
            }
        });
    }

    function createSignature(imgData) {
        // Convert 20x20 image to simple binary string
        let sig = "";
        const d = imgData.data;
        for(let i=0; i<d.length; i+=4) {
            // High contrast check
            sig += (d[i] > 100) ? "1" : "0";
        }
        return sig;
    }

    // --- TRAINING UI ---
    function startTraining() {
        if(trainingQueue.length === 0) {
            document.getElementById('trainModal').style.display = 'none';
            localStorage.setItem('sum10_blobs', JSON.stringify(templates));
            solve();
            return;
        }

        const b = trainingQueue[0];
        const modal = document.getElementById('trainModal');
        const tCanvas = document.getElementById('trainCanvas');
        const tCtx = tCanvas.getContext('2d');
        const input = document.getElementById('trainInput');

        tCanvas.width = b.w; tCanvas.height = b.h;
        tCtx.drawImage(document.getElementById('imgCanvas'), b.x, b.y, b.w, b.h, 0, 0, b.w, b.h);

        modal.style.display = 'flex';
        input.value = '';
        input.focus();
    }

    function saveTraining() {
        const val = parseInt(document.getElementById('trainInput').value);
        if(isNaN(val)) return;

        // Save for ALL items in queue with same signature (bulk solve)
        const sig = trainingQueue[0].signature;
        templates[sig] = val;

        // Remove processed items from queue
        trainingQueue = trainingQueue.filter(item => item.signature !== sig);
        startTraining(); // Next
    }

    document.getElementById('trainInput').addEventListener("keypress", function(event) {
        if (event.key === "Enter") saveTraining();
    });

    // --- SOLVER ---
    function solve() {
        // Clear Overlay
        drawDebugOverlay(); // Redraws detected boxes
        const ctx = document.getElementById('overlayCanvas').getContext('2d');
        
        let best = null;
        let maxScore = -1;

        // Greedy Algo
        for (let r1 = 0; r1 < ROWS; r1++) {
            for (let c1 = 0; c1 < COLS; c1++) {
                for (let r2 = r1; r2 < ROWS; r2++) {
                    for (let c2 = c1; c2 < COLS; c2++) {
                        let s = 0;
                        let count = 0;
                        for(let i=r1; i<=r2; i++){
                            for(let j=c1; j<=c2; j++){
                                let v = gridData[i][j];
                                s += v;
                                if(v>0) count++;
                            }
                        }
                        if (s === 10 && count > 0) {
                            let score = count * 1000 + ((r2-r1)*(c2-c1));
                            if (score > maxScore) {
                                maxScore = score;
                                best = { r1, c1, r2, c2, count };
                            }
                        }
                    }
                }
            }
        }

        const btn = document.getElementById('solveBtn');
        if (best) {
            currentMove = best;
            document.getElementById('status').innerText = `Best Match: Clears ${best.count} numbers!`;
            
            // Highlight Move
            // Convert Grid Coords back to Pixel Coords roughly
            // We use the min/max from blobs to estimate cell size again
            // Or simpler: Find bounding box of blobs involved
            
            // Re-calculate bounds
            let minX=99999, maxX=0, minY=99999, maxY=0;
            blobs.forEach(b => {
                if(b.x < minX) minX = b.x;
                if(b.x+b.w > maxX) maxX = b.x+b.w;
                if(b.y < minY) minY = b.y;
                if(b.y+b.h > maxY) maxY = b.y+b.h;
            });
            const cellW = (maxX-minX)/COLS;
            const cellH = (maxY-minY)/ROWS;

            const rx = minX + (best.c1 * cellW);
            const ry = minY + (best.r1 * cellH);
            const rw = ((best.c2 - best.c1 + 1) * cellW);
            const rh = ((best.r2 - best.r1 + 1) * cellH);

            ctx.strokeStyle = "#00ff00";
            ctx.lineWidth = 5;
            ctx.strokeRect(rx, ry, rw, rh);
            ctx.fillStyle = "rgba(0,255,0,0.3)";
            ctx.fillRect(rx, ry, rw, rh);

            btn.disabled = false;
            btn.innerHTML = `DONE (Found ${best.count} tiles)`;
        } else {
            document.getElementById('status').innerText = "No moves found.";
            btn.disabled = true;
            btn.innerText = "NO MOVES";
        }
    }

    function drawDebugOverlay() {
        const ctx = document.getElementById('overlayCanvas').getContext('2d');
        ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);
        
        ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
        ctx.lineWidth = 1;
        ctx.fillStyle = "rgba(255, 255, 255, 0.8)";
        ctx.font = "10px monospace";

        blobs.forEach(b => {
            // Draw box around detected blob
            ctx.strokeRect(b.x, b.y, b.w, b.h);
            
            // Draw number if known
            if (gridData[b.gridR] && gridData[b.gridR][b.gridC] > 0) {
                 ctx.fillText(gridData[b.gridR][b.gridC], b.x, b.y - 2);
            }
        });
    }

    function confirmMove() {
        if(!currentMove) return;
        // Zero out data
        for(let r=currentMove.r1; r<=currentMove.r2; r++){
            for(let c=currentMove.c1; c<=currentMove.c2; c++){
                gridData[r][c] = 0;
            }
        }
        // Remove blobs from visuals that were in that range to prevent re-finding
        // Actually, easiest is just to re-run solve on updated gridData
        solve();
    }

    function clearData() {
        if(confirm("Reset all learned numbers?")) {
            localStorage.removeItem('sum10_blobs');
            location.reload();
        }
    }

</script>
</body>
</html>
