<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sum-10 Ultimate Solver</title>
    <style>
        :root { --bg: #121212; --panel: #1f1f1f; --accent: #2196f3; --green: #00e676; --red: #ff5252; }
        body { background: var(--bg); color: #e0e0e0; font-family: 'Segoe UI', sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        
        /* Layout */
        .main-container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; align-items: flex-start; }
        
        /* Canvas Stage */
        .stage { position: relative; border: 2px solid #333; background: #000; min-width: 320px; min-height: 240px; display: flex; justify-content: center; align-items: center; }
        canvas { display: block; image-rendering: pixelated; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        .placeholder { color: #666; pointer-events: none; }

        /* Controls Panel */
        .panel { width: 340px; background: var(--panel); padding: 20px; border-radius: 8px; box-shadow: 0 4px 20px rgba(0,0,0,0.5); }
        
        .status { font-weight: bold; margin-bottom: 15px; color: #ffca28; min-height: 1.2em; font-size: 0.9em; }
        
        .btn { width: 100%; padding: 12px; border: none; border-radius: 4px; font-weight: bold; cursor: pointer; font-size: 16px; margin-bottom: 10px; transition: 0.2s; color: white; background: #424242; }
        .btn-green { background: var(--green); color: #000; }
        .btn-green:hover { transform: scale(1.02); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }

        /* Sliders */
        .slider-group { margin: 15px 0; padding: 10px; background: #2c2c2c; border-radius: 6px; }
        .slider-header { display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa; margin-bottom: 5px; }
        input[type=range] { width: 100%; cursor: pointer; }

        /* View Toggle */
        .toggle-row { display: flex; gap: 5px; margin-bottom: 10px; }
        .toggle-btn { flex: 1; padding: 8px; font-size: 0.8em; background: #333; border: 1px solid #444; color: #888; cursor: pointer; text-align: center; }
        .toggle-btn.active { background: var(--accent); color: white; border-color: var(--accent); }

        /* Training Modal */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.95); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-box { background: #222; padding: 25px; border-radius: 12px; text-align: center; border: 1px solid #444; max-width: 300px; }
        .train-preview { width: 64px; height: 64px; border: 1px solid #666; margin: 15px auto; display: block; image-rendering: pixelated; }
        
        .train-actions { display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px; }
        .train-input { font-size: 24px; padding: 5px; text-align: center; background: #111; color: white; border: 1px solid #555; width: 100%; box-sizing: border-box; }
        
        .btn-ignore { background: var(--red); color: white; font-size: 0.8em; }
    </style>
</head>
<body>

    <h2 style="margin-top:0; color:var(--accent)">ahhh</h2>
    
    <div class="main-container">
        <!-- Visual Stage -->
        <div class="stage">
            <span class="placeholder">Paste Screenshot (Ctrl+V)</span>
            <canvas id="mainCanvas" style="display:none"></canvas>
            <canvas id="overlayCanvas"></canvas>
        </div>

        <!-- Right Panel -->
        <div class="panel">
            <div id="status" class="status">Waiting for image...</div>

            <!-- View Toggles -->
            <div class="toggle-row">
                <div class="toggle-btn active" id="viewNormal" onclick="setView('normal')">Normal View</div>
                <div class="toggle-btn" id="viewDebug" onclick="setView('debug')">Computer Vision</div>
            </div>

            <!-- Sliders -->
            <div class="slider-group">
                <div class="slider-header"><span>Brightness Threshold</span> <span id="threshVal">180</span></div>
                <input type="range" id="threshold" min="100" max="250" value="180" oninput="process()">
                <div style="font-size:0.7em; color:#888; margin-top:5px;">Increase if detecting bucket rims. Decrease if detecting nothing.</div>
            </div>

            <button id="solveBtn" class="btn btn-green" disabled onclick="confirmMove()">SOLVE BOARD</button>
            
            <div style="text-align:center; font-size:0.8em; margin-top:15px; cursor:pointer; color:#777;" onclick="clearMemory()">
                [ Reset Learned Memory ]
            </div>
        </div>
    </div>

    <!-- Training Modal -->
    <div id="trainModal" class="modal">
        <div class="modal-box">
            <h3>Unknown Shape</h3>
            <p style="color:#aaa; font-size:0.8em;">Is this a number?</p>
            
            <!-- We show the normalized version so user sees exactly what computer sees -->
            <canvas id="trainCanvas" class="train-preview"></canvas>
            
            <input type="number" id="trainInput" class="train-input" min="0" max="9" placeholder="#">
            
            <div class="train-actions">
                <button class="btn btn-ignore" style="margin:0" onclick="ignoreShape()">IGNORE (Garbage)</button>
                <button class="btn btn-green" style="margin:0" onclick="saveShape()">SAVE</button>
            </div>
        </div>
    </div>

<script>
    // --- SETTINGS ---
    const ROWS = 15;
    const COLS = 10;
    const NORM_SIZE = 16; // Uniform size for all shapes
    const MATCH_STRICTNESS = 0.85; // 85% similarity required to auto-match
    
    // --- STATE ---
    let srcImg = null;
    let viewMode = 'normal'; // 'normal' or 'debug'
    let gridData = [];
    let blobs = [];
    let trainingQueue = [];
    let currentBest = null;
    
    // Memory: [ { label: 5, data: [0,1,0...] }, ... ]
    let memory = JSON.parse(localStorage.getItem('sum10_ultimate_mem')) || [];

    // --- INPUT HANDLER ---
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => { srcImg = img; process(); };
            }
        }
    });

    // --- MAIN PROCESS ---
    function process() {
        if (!srcImg) return;
        
        // 1. Setup Canvas
        document.querySelector('.placeholder').style.display = 'none';
        const cvs = document.getElementById('mainCanvas');
        const ctx = cvs.getContext('2d');
        const ovl = document.getElementById('overlayCanvas');
        
        cvs.style.display = 'block';
        cvs.width = srcImg.width; cvs.height = srcImg.height;
        ovl.width = srcImg.width; ovl.height = srcImg.height;

        const thresh = parseInt(document.getElementById('threshold').value);
        document.getElementById('threshVal').innerText = thresh;

        // 2. Draw & Threshold
        ctx.drawImage(srcImg, 0, 0);
        const rawData = ctx.getImageData(0, 0, cvs.width, cvs.height);
        
        // 3. Find Blobs
        blobs = detectBlobs(rawData, cvs.width, cvs.height, thresh);

        // 4. Map to Grid
        gridData = mapBlobsToGrid(blobs);

        // 5. Recognize
        trainingQueue = [];
        let recognizedCount = 0;

        blobs.forEach(b => {
            if(b.gridR === null) return; // Not on grid

            // Normalize Shape (Elastic Resize)
            const feature = extractFeature(ctx, b);
            
            // Match
            const match = findMatch(feature);
            
            if (match) {
                if (match.label === -1) {
                    // This is known garbage (ignore)
                    b.isGarbage = true;
                } else {
                    gridData[b.gridR][b.gridC] = match.label;
                    b.label = match.label;
                    recognizedCount++;
                }
            } else {
                // Unknown shape
                b.feature = feature;
                trainingQueue.push(b);
            }
        });

        // 6. Update UI
        drawOverlay();
        
        if (trainingQueue.length > 0) {
            document.getElementById('status').innerText = `Training Required: ${trainingQueue.length} new shapes found.`;
            startTraining();
        } else if (recognizedCount > 0) {
            document.getElementById('status').innerText = `Ready. Found ${recognizedCount} numbers.`;
            solve();
        } else {
            document.getElementById('status').innerText = "No numbers found. Check Threshold slider.";
            document.getElementById('solveBtn').disabled = true;
        }
    }

    // --- BLOB DETECTION ---
    function detectBlobs(imgData, w, h, threshold) {
        const d = imgData.data;
        const visited = new Uint8Array(w * h);
        const results = [];

        for(let i=0; i<w*h; i++) {
            if(visited[i]) continue;
            
            // Brightness check
            const bright = (d[i*4]+d[i*4+1]+d[i*4+2])/3;
            
            if(bright > threshold) {
                // Flood Fill
                let stack = [i];
                visited[i] = 1;
                let minX=w, maxX=0, minY=h, maxY=0;
                let pixelCount = 0;

                while(stack.length) {
                    const cur = stack.pop();
                    const cx = cur % w;
                    const cy = Math.floor(cur / w);
                    
                    if(cx<minX) minX=cx;
                    if(cx>maxX) maxX=cx;
                    if(cy<minY) minY=cy;
                    if(cy>maxY) maxY=cy;
                    pixelCount++;

                    const neighbors = [cur+1, cur-1, cur+w, cur-w];
                    for(let n of neighbors) {
                        if(n>=0 && n<w*h && !visited[n]) {
                            const nb = (d[n*4]+d[n*4+1]+d[n*4+2])/3;
                            if(nb > threshold) {
                                visited[n] = 1;
                                stack.push(n);
                            }
                        }
                    }
                }

                const width = maxX - minX + 1;
                const height = maxY - minY + 1;

                // FILTER: Remove "Gibberish"
                // 1. Must be reasonably sized (bigger than dust, smaller than screen)
                // 2. Must not be extremely wide (bucket rims are wide and short)
                const ratio = width / height;
                if (width > 5 && height > 8 && width < 50 && height < 50 && ratio < 1.5) {
                    results.push({ x:minX, y:minY, w:width, h:height });
                }
            }
        }
        return results;
    }

    // --- FEATURE EXTRACTION (ELASTIC RESIZE) ---
    function extractFeature(ctx, b) {
        // Create normalized 16x16 canvas
        const tc = document.createElement('canvas');
        tc.width = NORM_SIZE; tc.height = NORM_SIZE;
        const tctx = tc.getContext('2d');

        // Draw the blob stretched to exactly 16x16
        // This solves the issue of different fonts/sizes looking different
        tctx.drawImage(ctx.canvas, b.x, b.y, b.w, b.h, 0, 0, NORM_SIZE, NORM_SIZE);

        // Binarize result (0 or 1)
        const id = tctx.getImageData(0,0,NORM_SIZE,NORM_SIZE);
        const binData = [];
        for(let i=0; i<id.data.length; i+=4) {
            // High contrast check
            binData.push(id.data[i] > 100 ? 1 : 0);
        }
        return binData;
    }

    // --- MATCHING LOGIC ---
    function findMatch(feature) {
        if(memory.length === 0) return null;
        
        let bestItem = null;
        let maxSim = -1;

        memory.forEach(mem => {
            // Calculate Similarity %
            let matches = 0;
            const total = feature.length;
            for(let i=0; i<total; i++) {
                if(feature[i] === mem.data[i]) matches++;
            }
            const sim = matches / total;
            
            if(sim > maxSim) {
                maxSim = sim;
                bestItem = mem;
            }
        });

        if (maxSim >= MATCH_STRICTNESS) return bestItem;
        return null;
    }

    // --- GRID MAPPING (Adaptive) ---
    function mapBlobsToGrid(rawBlobs) {
        let grid = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        if(rawBlobs.length === 0) return grid;
        
        // Find grid bounds
        let minX=9999, maxX=0, minY=9999, maxY=0;
        rawBlobs.forEach(b => {
            if(b.x < minX) minX=b.x;
            if(b.x+b.w > maxX) maxX=b.x+b.w;
            if(b.y < minY) minY=b.y;
            if(b.y+b.h > maxY) maxY=b.y+b.h;
        });

        const totalW = maxX - minX;
        const totalH = maxY - minY;
        
        // Approx cell size
        const cellW = totalW / 9.5; // (10 cols - padding)
        const cellH = totalH / 14.5; // (15 rows - padding)

        rawBlobs.forEach(b => {
            const cx = b.x + b.w/2;
            const cy = b.y + b.h/2;
            
            const c = Math.round((cx - minX) / (totalW/9));
            const r = Math.round((cy - minY) / (totalH/14));

            if(c>=0 && c<COLS && r>=0 && r<ROWS) {
                b.gridR = r; b.gridC = c;
            } else {
                b.gridR = null;
            }
        });
        return grid;
    }

    // --- TRAINING UI ---
    function startTraining() {
        if(trainingQueue.length === 0) {
            document.getElementById('trainModal').style.display = 'none';
            localStorage.setItem('sum10_ultimate_mem', JSON.stringify(memory));
            process(); // Re-run to solve
            return;
        }

        const b = trainingQueue[0];
        const modal = document.getElementById('trainModal');
        const prev = document.getElementById('trainCanvas');
        const inp = document.getElementById('trainInput');
        
        // Render preview
        prev.width = NORM_SIZE; prev.height = NORM_SIZE;
        const ctx = prev.getContext('2d');
        const img = ctx.createImageData(NORM_SIZE, NORM_SIZE);
        for(let i=0; i<b.feature.length; i++) {
            const val = b.feature[i] * 255;
            img.data[i*4] = val;   // R
            img.data[i*4+1] = val; // G
            img.data[i*4+2] = val; // B
            img.data[i*4+3] = 255; // Alpha
        }
        ctx.putImageData(img, 0, 0);

        // Reset UI
        modal.style.display = 'flex';
        inp.value = '';
        inp.focus();
    }

    function saveShape() {
        const val = parseInt(document.getElementById('trainInput').value);
        if(isNaN(val)) return;

        // Add to memory
        memory.push({ label: val, data: trainingQueue[0].feature });
        
        // Remove from queue
        trainingQueue.shift();
        startTraining();
    }

    function ignoreShape() {
        // Add as label -1 (Garbage)
        memory.push({ label: -1, data: trainingQueue[0].feature });
        trainingQueue.shift();
        startTraining();
    }

    document.getElementById('trainInput').addEventListener("keydown", (e) => {
        if(e.key === "Enter") saveShape();
    });

    // --- SOLVER ---
    function solve() {
        let best = null;
        let maxScore = -1;

        for (let r1 = 0; r1 < ROWS; r1++) {
            for (let c1 = 0; c1 < COLS; c1++) {
                for (let r2 = r1; r2 < ROWS; r2++) {
                    for (let c2 = c1; c2 < COLS; c2++) {
                        let sum = 0;
                        let count = 0;
                        for(let i=r1; i<=r2; i++){
                            for(let j=c1; j<=c2; j++){
                                let v = gridData[i][j];
                                sum += v;
                                if(v>0) count++;
                            }
                        }
                        if(sum === 10 && count > 0) {
                            let score = (count * 1000) + ((r2-r1)*(c2-c1));
                            if(score > maxScore) {
                                maxScore = score;
                                best = { r1, c1, r2, c2, count };
                            }
                        }
                    }
                }
            }
        }

        currentBest = best;
        const btn = document.getElementById('solveBtn');

        if(best) {
            document.getElementById('status').innerText = `Best Move: Clears ${best.count} tiles.`;
            btn.innerHTML = "MATCH DONE (Next)";
            btn.disabled = false;
            drawOverlay(best);
        } else {
            document.getElementById('status').innerText = "No moves available.";
            btn.innerText = "NO MOVES";
            btn.disabled = true;
            drawOverlay();
        }
    }

    // --- DRAWING UTILS ---
    function drawOverlay(highlight = null) {
        const cvs = document.getElementById('overlayCanvas');
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0,0,cvs.width,cvs.height);

        const isDebug = viewMode === 'debug';

        // Draw all blobs
        blobs.forEach(b => {
            if(b.isGarbage) return; // Don't show garbage

            if(isDebug) {
                ctx.strokeStyle = "rgba(255, 0, 0, 0.5)";
                ctx.lineWidth = 1;
                ctx.strokeRect(b.x, b.y, b.w, b.h);
            }
            
            if(b.label) {
                // If recognized, show number
                ctx.fillStyle = "#00e676";
                ctx.font = "bold 14px sans-serif";
                ctx.fillText(b.label, b.x, b.y-2);
            }
        });

        // Highlight Solution
        if(highlight) {
            // Find bounding box of solution blobs
            let minX=9999, maxX=0, minY=9999, maxY=0;
            let found = false;

            blobs.forEach(b => {
                if(b.gridR >= highlight.r1 && b.gridR <= highlight.r2 && 
                   b.gridC >= highlight.c1 && b.gridC <= highlight.c2 && !b.isGarbage) {
                    if(b.x < minX) minX = b.x;
                    if(b.x+b.w > maxX) maxX = b.x+b.w;
                    if(b.y < minY) minY = b.y;
                    if(b.y+b.h > maxY) maxY = b.y+b.h;
                    found = true;
                }
            });

            if(found) {
                const pad = 4;
                ctx.strokeStyle = "#00e676";
                ctx.lineWidth = 4;
                ctx.strokeRect(minX-pad, minY-pad, (maxX-minX)+pad*2, (maxY-minY)+pad*2);
                ctx.fillStyle = "rgba(0, 230, 118, 0.3)";
                ctx.fillRect(minX-pad, minY-pad, (maxX-minX)+pad*2, (maxY-minY)+pad*2);
            }
        }
    }

    function setView(mode) {
        viewMode = mode;
        document.getElementById('viewNormal').classList.toggle('active', mode === 'normal');
        document.getElementById('viewDebug').classList.toggle('active', mode === 'debug');
        
        const cvs = document.getElementById('mainCanvas');
        const ctx = cvs.getContext('2d');
        const thresh = parseInt(document.getElementById('threshold').value);

        // Repaint background
        if(mode === 'debug') {
            ctx.drawImage(srcImg, 0, 0);
            const d = ctx.getImageData(0,0,cvs.width,cvs.height);
            for(let i=0; i<d.data.length; i+=4) {
                const b = (d.data[i]+d.data[i+1]+d.data[i+2])/3;
                const v = b > thresh ? 255 : 0;
                d.data[i] = v; d.data[i+1] = v; d.data[i+2] = v;
            }
            ctx.putImageData(d, 0, 0);
        } else {
            ctx.drawImage(srcImg, 0, 0);
        }
        drawOverlay(currentBest);
    }

    function confirmMove() {
        if(!currentBest) return;
        // Clear data
        for(let r=currentBest.r1; r<=currentBest.r2; r++) {
            for(let c=currentBest.c1; c<=currentBest.c2; c++) {
                gridData[r][c] = 0;
            }
        }
        // Remove blobs to prevent re-read
        blobs = blobs.filter(b => 
           !(b.gridR >= currentBest.r1 && b.gridR <= currentBest.r2 && 
             b.gridC >= currentBest.c1 && b.gridC <= currentBest.c2)
        );
        solve();
    }

    function clearMemory() {
        if(confirm("Erase all learned shapes?")) {
            localStorage.removeItem('sum10_ultimate_mem');
            location.reload();
        }
    }
</script>
</body>
</html>
