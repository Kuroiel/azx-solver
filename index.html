<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sum-10 Safety Solver</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #2979ff; --gold: #ffd740; --green: #00e676; --error: #ff1744; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: #e0e0e0; display: flex; flex-direction: column; align-items: center; padding: 20px; height: 100vh; margin: 0; }
        
        .layout { display: flex; flex-direction: row-reverse; gap: 20px; flex-wrap: wrap-reverse; justify-content: center; align-items: flex-start; width: 100%; max-width: 1200px; }
        
        .stage { 
            position: relative; 
            border: 3px dashed #444; 
            background: #080808; 
            cursor: crosshair; 
            min-width: 400px; 
            min-height: 300px; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            outline: none;
        }
        .stage:focus { border-color: var(--accent); }
        
        canvas { display: block; image-rendering: pixelated; max-width: 100%; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        .placeholder-text { pointer-events: none; color: #555; font-size: 1.5em; font-weight: bold; text-align: center; }
        
        .panel { width: 300px; background: var(--panel); padding: 20px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.5); display: flex; flex-direction: column; }
        .status { font-weight: bold; margin-bottom: 15px; color: var(--accent); min-height: 1.2em; font-size: 0.9em; border-bottom: 1px solid #333; padding-bottom: 10px; }
        
        .btn { width: 100%; padding: 25px; border: none; border-radius: 6px; font-weight: bold; font-size: 20px; cursor: pointer; background: #333; color: #777; transition: 0.1s; margin-top: 10px;}
        .btn.active { background: var(--green); color: #000; box-shadow: 0 0 20px rgba(0, 230, 118, 0.3); animation: pulse 1.5s infinite; }
        .btn:active { transform: translateY(2px); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; animation: none; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

        .slider-box { margin: 15px 0; padding: 10px; background: #2a2a2a; border-radius: 4px; border: 1px solid #333; }
        .slider-header { display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa; margin-bottom: 5px; }

        .info-text { font-size: 0.8em; color: #aaa; margin-top: 20px; text-align: center; line-height: 1.5; }
        .highlight { color: var(--green); font-weight: bold; }
        .warning { color: var(--error); font-weight: bold; }

        .tooltip { position: absolute; background: rgba(0,0,0,0.95); padding: 15px; border: 1px solid #fff; border-radius: 6px; pointer-events: none; display: none; transform: translate(-50%, -100%); margin-top: -15px; text-align: center; z-index: 100; box-shadow: 0 5px 15px black;}
        .tooltip-img { width: 48px; height: 48px; border: 1px solid #555; display: block; margin: 0 auto 10px; image-rendering: pixelated; }
    </style>
</head>
<body>

    <h2 style="color:var(--accent); margin-top:0;">QEII Cup</h2>
    
    <div class="layout">
        <div class="stage" id="stageContainer" tabindex="0">
            <div id="placeholder" class="placeholder-text">CLICK HERE<br><span style="font-size:0.6em">CTRL+V</span></div>
            <canvas id="mainCanvas" style="display:none"></canvas>
            <canvas id="overlayCanvas"></canvas>
            <div id="correctionTooltip" class="tooltip">
                <canvas id="tooltipCanvas" class="tooltip-img"></canvas>
                <div>Type Correct Number</div>
            </div>
        </div>

        <div class="panel">
            <div id="status" class="status">Waiting for image...</div>

            <div class="slider-box">
                <div class="slider-header"><span>Contrast Filter</span> <span id="threshVal">140</span></div>
                <input type="range" id="threshold" min="80" max="220" value="140" style="width:100%" oninput="process()">
            </div>

            <button id="solveBtn" class="btn" disabled onclick="applyMove()">MOVE DONE</button>
            
            <div class="info-text">
                <span class="warning">Red Box = BLOCKED</span><br>
                This happens if a number is too dim or unknown.<br>
                <b>Click Red Boxes to fix them</b>, otherwise the solver works around them.
            </div>
            
            <div style="margin-top:auto; text-align:center; font-size:0.7em; color:#555; cursor:pointer;" onclick="resetMem()">
                [ Clear Learned Data ]
            </div>
        </div>
    </div>

<script>
    // --- CONFIG ---
    const ROWS = 15;
    const COLS = 10;
    const NORM_SIZE = 16;
    
    const ASCII_DIGITS = {
        1: ["  #  "," ##  ","  #  ","  #  ","  #  ","  #  "," ### "],
        2: [" ### ","#   #","    #","   # ","  #  "," #   ","#####"],
        3: ["#####","    #","   # ","    #","    #","#   #"," ### "],
        4: ["   # ","  ## "," # # ","#  # ","#####","   # ","   # "],
        5: ["#####","#    ","#### ","    #","    #","#   #"," ### "],
        6: [" ### ","#    ","#    ","#### ","#   #","#   #"," ### "],
        7: ["#####","    #","   # ","  #  "," #   "," #   "," #   "],
        8: [" ### ","#   #"," ### ","#   #","#   #","#   #"," ### "],
        9: [" ### ","#   #","#   #"," ####","    #","   # "," ### "],
        0: [" ### ","#   #","#   #","#   #","#   #","#   #"," ### "]
    };

    let srcImg = null;
    let gridData = [];
    let blobs = [];
    let currentMove = null;
    let userMemory = JSON.parse(localStorage.getItem('sum10_pro_mem')) || [];
    let systemMemory = [];
    let gridMetrics = { minX:0, maxX:0, minY:0, maxY:0 };

    // --- INIT ---
    generateSystemMemory();
    
    document.addEventListener('paste', e => {
        e.preventDefault();
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                document.getElementById('status').innerText = "Processing...";
                img.onload = () => { 
                    srcImg = img; 
                    document.getElementById('placeholder').style.display = 'none';
                    document.getElementById('mainCanvas').style.display = 'block';
                    process(); 
                };
            }
        }
    });

    const stage = document.getElementById('stageContainer');
    const tooltip = document.getElementById('correctionTooltip');
    let correctionTarget = null; 
    let correctionGridPos = null;

    stage.addEventListener('click', () => stage.focus());

    stage.addEventListener('mousedown', e => {
        if(!srcImg || gridMetrics.maxX === 0) return;
        const rect = stage.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Map click to grid coordinates
        const tW = gridMetrics.maxX - gridMetrics.minX;
        const tH = gridMetrics.maxY - gridMetrics.minY;
        const stepX = tW / 9; 
        const stepY = tH / 14;

        const c = Math.round((x - gridMetrics.minX) / stepX);
        const r = Math.round((y - gridMetrics.minY) / stepY);

        if(c>=0 && c<COLS && r>=0 && r<ROWS) {
            correctionGridPos = { r, c };
            
            // Visual feedback
            tooltip.style.display = 'block';
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
            
            // Try to find a blob visual for context, or just show text
            const b = blobs.find(b => b.gridR === r && b.gridC === c);
            if(b) {
                const tc = document.getElementById('tooltipCanvas');
                tc.width = NORM_SIZE; tc.height = NORM_SIZE;
                const tctx = tc.getContext('2d');
                const img = tctx.createImageData(NORM_SIZE, NORM_SIZE);
                for(let i=0; i<b.feature.length; i++) {
                    const v = b.feature[i]*255;
                    img.data[i*4]=v; img.data[i*4+1]=v; img.data[i*4+2]=v; img.data[i*4+3]=255;
                }
                tctx.putImageData(img,0,0);
                correctionTarget = b;
            } else {
                // Clicking an empty/ghost spot
                correctionTarget = null;
                const tc = document.getElementById('tooltipCanvas');
                tc.width=1; tc.height=1; // hide canvas
            }
            e.stopPropagation();
        } else {
            tooltip.style.display = 'none';
        }
    });

    window.addEventListener('keydown', e => {
        if(correctionGridPos && e.key >= '0' && e.key <= '9') {
            const num = parseInt(e.key);
            
            // If there's a blob, learn it. If not, just force grid data.
            if(correctionTarget) {
                userMemory.push({ label: num, data: correctionTarget.feature });
                localStorage.setItem('sum10_pro_mem', JSON.stringify(userMemory));
            }
            
            // Force the value into the grid logic (overriding auto-detect)
            // We use a temporary override or just re-process. 
            // Since we can't easily inject into process() loop without blob,
            // We will let the user fix blobs, but for "ghosts", we just rely on future teaching?
            // Actually, best is to just re-process.
            tooltip.style.display = 'none';
            process(); 
        }
    });

    // --- MAIN PIPELINE ---
    function process() {
        if(!srcImg) return;
        
        const thresh = parseInt(document.getElementById('threshold').value);
        document.getElementById('threshVal').innerText = thresh;

        const cvs = document.getElementById('mainCanvas');
        const ctx = cvs.getContext('2d');
        const ovl = document.getElementById('overlayCanvas');
        
        cvs.width = srcImg.width; cvs.height = srcImg.height;
        ovl.width = srcImg.width; ovl.height = srcImg.height;

        ctx.drawImage(srcImg, 0, 0);

        const raw = ctx.getImageData(0,0,cvs.width,cvs.height);
        
        // 1. Detect
        blobs = detectBlobs(raw, cvs.width, cvs.height, thresh);
        
        // 2. Map & Setup Grid
        gridData = mapBlobsToGrid(blobs);

        // 3. Recognize
        blobs.forEach(b => {
            if(b.gridR === null) return;
            b.feature = extractFeature(ctx, b);
            
            let match = findBestMatch(b.feature, userMemory);
            if(!match) match = findBestMatch(b.feature, systemMemory, 50);

            if(match) {
                if(match.label !== -1) {
                    gridData[b.gridR][b.gridC] = match.label;
                    b.label = match.label;
                } else {
                    b.isGarbage = true;
                    gridData[b.gridR][b.gridC] = -1; 
                }
            } else {
                const forced = findBestMatch(b.feature, systemMemory, Infinity);
                gridData[b.gridR][b.gridC] = forced.label;
                b.label = forced.label;
                b.lowConf = true;
            }
        });

        // 4. GHOST DETECTION (The Safety Fix)
        // Check grid spots that are '0' (Empty). If they have pixels, mark -1 (Blocked).
        detectGhosts(ctx, thresh);

        calculateStrategicMove();
    }

    // --- GHOST DETECTOR ---
    function detectGhosts(ctx, thresh) {
        if(gridMetrics.maxX === 0) return;

        const tW = gridMetrics.maxX - gridMetrics.minX;
        const tH = gridMetrics.maxY - gridMetrics.minY;
        const stepX = tW / 9; 
        const stepY = tH / 14;

        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(gridData[r][c] === 0) {
                    // It says empty. Let's verify.
                    // Calculate center of this cell
                    const cx = gridMetrics.minX + (c * stepX);
                    const cy = gridMetrics.minY + (r * stepY);
                    
                    // Sample a small 10x10 box in center
                    const s = 10;
                    const sample = ctx.getImageData(cx - s/2, cy - s/2, s, s).data;
                    let brightPixels = 0;
                    
                    for(let i=0; i<sample.length; i+=4) {
                        const b = (sample[i]+sample[i+1]+sample[i+2])/3;
                        if(b > thresh) brightPixels++;
                    }

                    // If we see more than a few bright pixels, but no blob was mapped...
                    // It's a GHOST (Unread number).
                    if(brightPixels > 5) {
                        gridData[r][c] = -1; // BLOCK IT
                    }
                }
            }
        }
    }

    // --- STRATEGY ENGINE ---
    function calculateStrategicMove() {
        const currentMoves = getAllMoves(gridData);
        
        if (currentMoves.length === 0) {
            currentMove = null;
            drawScene();
            return;
        }

        const candidates = currentMoves.slice(0, 15);
        let bestStrategy = null;
        let maxTotalPoints = -1;

        for (let move of candidates) {
            const simGrid = cloneGrid(gridData);
            applyMoveToGrid(simGrid, move);
            
            const nextMoves = getAllMoves(simGrid);
            const bestNext = nextMoves.length > 0 ? nextMoves[0] : null;
            
            const nextScore = bestNext ? bestNext.count : 0;
            const totalScore = move.count + nextScore;

            if (totalScore > maxTotalPoints) {
                maxTotalPoints = totalScore;
                bestStrategy = move;
                bestStrategy.predictedNext = nextScore;
            }
        }

        currentMove = bestStrategy;
        drawScene();
    }

    function getAllMoves(grid) {
        let moves = [];
        for (let r1=0; r1<ROWS; r1++) {
            for (let c1=0; c1<COLS; c1++) {
                for (let r2=r1; r2<ROWS; r2++) {
                    for (let c2=c1; c2<COLS; c2++) {
                        let sum=0, count=0;
                        let blocked = false;

                        for(let i=r1; i<=r2; i++){
                            for(let j=c1; j<=c2; j++){
                                let v = grid[i][j];
                                if (v === -1) { blocked = true; break; } 
                                sum+=v; 
                                if(v>0) count++;
                            }
                            if(blocked) break;
                        }
                        
                        // Strict check: Sum=10, No Blocks, Count > 1 (can't match single number)
                        if(!blocked && sum === 10 && count > 1) {
                            moves.push({
                                r1, c1, r2, c2, count,
                                area: (r2-r1+1)*(c2-c1+1)
                            });
                        }
                    }
                }
            }
        }
        return moves.sort((a, b) => b.count - a.count);
    }

    // --- DRAWING ---
    function drawScene() {
        const cvs = document.getElementById('overlayCanvas');
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0,0,cvs.width,cvs.height);

        // Calculate Steps for Drawing
        let stepX=0, stepY=0;
        if(gridMetrics.maxX > 0) {
            const tW = gridMetrics.maxX - gridMetrics.minX;
            const tH = gridMetrics.maxY - gridMetrics.minY;
            stepX = tW / 9; 
            stepY = tH / 14;
        }

        // Draw Cell Statuses
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                const val = gridData[r][c];
                
                // Calculate position for drawing non-blob cells (Ghosts/Blackouts)
                const cx = gridMetrics.minX + (c * stepX);
                const cy = gridMetrics.minY + (r * stepY);
                const boxS = stepX * 0.6; 

                if (val === 0) {
                    // Confirmed Empty - Draw Blackout
                    ctx.fillStyle = "rgba(0,0,0,0.85)";
                    ctx.fillRect(cx - boxS/2, cy - boxS/2, boxS, boxS);
                } else if (val === -1) {
                    // Blocked/Ghost - Draw Red Box
                    ctx.strokeStyle = "red";
                    ctx.lineWidth = 2;
                    ctx.strokeRect(cx - boxS/2, cy - boxS/2, boxS, boxS);
                }
            }
        }

        // Draw Blobs (Detected Numbers)
        blobs.forEach(b => {
            if(gridData[b.gridR][b.gridC] <= 0) return; // Skip if blocked or empty

            const labelX = b.x - 2;
            const labelY = b.y - 12;
            const size = 14;

            ctx.fillStyle = b.lowConf ? "#ffd740" : "#69f0ae"; 
            ctx.beginPath();
            ctx.roundRect(labelX, labelY, size, size, 2);
            ctx.fill();

            ctx.font = "bold 11px Arial";
            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(b.label, labelX + size/2, labelY + size/2 + 1);
        });

        const btn = document.getElementById('solveBtn');
        if(currentMove) {
            btn.disabled = false;
            btn.className = "btn active";
            
            let statusText = `Clears ${currentMove.count}`;
            if(currentMove.predictedNext > 0) statusText += ` (+${currentMove.predictedNext} next)`;
            
            btn.innerHTML = `MOVE DONE<br><span style="font-size:0.6em; font-weight:normal">${statusText}</span>`;
            document.getElementById('status').innerText = "Best Move Calculated.";

            const x1 = gridMetrics.minX + (currentMove.c1 * stepX) - (stepX/2);
            const y1 = gridMetrics.minY + (currentMove.r1 * stepY) - (stepY/2);
            const x2 = gridMetrics.minX + (currentMove.c2 * stepX) + (stepX/2); 
            const y2 = gridMetrics.minY + (currentMove.r2 * stepY) + (stepY/2);
            
            const rectW = x2 - x1;
            const rectH = y2 - y1;

            const pad = 2;
            ctx.strokeStyle = "#00e676"; 
            ctx.lineWidth = 4;
            ctx.strokeRect(x1+pad, y1+pad, rectW-pad*2, rectH-pad*2);
            ctx.fillStyle = "rgba(105, 240, 174, 0.25)";
            ctx.fillRect(x1+pad, y1+pad, rectW-pad*2, rectH-pad*2);

        } else {
            btn.disabled = true;
            btn.className = "btn";
            btn.innerHTML = "NO MOVES";
            document.getElementById('status').innerText = "Board cleared or stuck.";
        }
    }

    function applyMove() {
        if(!currentMove) return;
        applyMoveToGrid(gridData, currentMove);
        calculateStrategicMove();
    }

    // --- HELPERS ---
    function detectBlobs(imgData, w, h, t) {
        const d=imgData.data, v=new Uint8Array(w*h), res=[];
        for(let i=0; i<w*h; i+=2) {
            if(v[i])continue;
            if((d[i*4]+d[i*4+1]+d[i*4+2])/3 > t) {
                let s=[i], minX=w, maxX=0, minY=h, maxY=0; v[i]=1;
                while(s.length){
                    const c=s.pop(), cx=c%w, cy=Math.floor(c/w);
                    if(cx<minX)minX=cx; if(cx>maxX)maxX=cx; if(cy<minY)minY=cy; if(cy>maxY)maxY=cy;
                    [c+1,c-1,c+w,c-w].forEach(n=>{
                        if(n>=0 && n<w*h && !v[n] && (d[n*4]+d[n*4+1]+d[n*4+2])/3 > t){v[n]=1;s.push(n);}
                    });
                }
                const width=maxX-minX+1, height=maxY-minY+1;
                if(width>3 && height>6 && width<60 && height<60) res.push({x:minX, y:minY, w:width, h:height});
            }
        }
        return res;
    }

    function extractFeature(ctx, b) {
        const c=document.createElement('canvas'); c.width=NORM_SIZE; c.height=NORM_SIZE;
        const x=c.getContext('2d'); x.drawImage(ctx.canvas,b.x,b.y,b.w,b.h,0,0,NORM_SIZE,NORM_SIZE);
        const d=x.getImageData(0,0,NORM_SIZE,NORM_SIZE).data, a=[];
        for(let i=0; i<d.length; i+=4) a.push(d[i]>100?1:0);
        return a;
    }

    function findBestMatch(f, lib, maxErr=30) {
        let best=null, min=Infinity;
        lib.forEach(l=>{
            let e=0; for(let i=0;i<256;i++)if(f[i]!==l.data[i])e++;
            if(e<min){min=e; best=l;}
        });
        return min<=maxErr ? best : null;
    }

    function mapBlobsToGrid(blobs) {
        let g=Array(ROWS).fill().map(()=>Array(COLS).fill(0));
        if(!blobs.length) return g;
        
        const xs = blobs.map(b=>b.x).sort((a,b)=>a-b);
        const ys = blobs.map(b=>b.y).sort((a,b)=>a-b);
        const qMinX = xs[Math.floor(xs.length*0.02)];
        const qMaxX = xs[Math.floor(xs.length*0.98)] + 20; 
        const qMinY = ys[Math.floor(ys.length*0.02)];
        const qMaxY = ys[Math.floor(ys.length*0.98)] + 20;

        let minX=9999, maxX=0, minY=9999, maxY=0;
        blobs.forEach(b=>{
            if(b.x >= qMinX && b.x <= qMaxX && b.y >= qMinY && b.y <= qMaxY) {
                if(b.x<minX)minX=b.x; if(b.x+b.w>maxX)maxX=b.x+b.w;
                if(b.y<minY)minY=b.y; if(b.y+b.h>maxY)maxY=b.y+b.h;
            }
        });

        gridMetrics = { minX, maxX, minY, maxY };

        const tW=maxX-minX;
        const tH=maxY-minY;
        const stepX = tW / 9; 
        const stepY = tH / 14;

        blobs.forEach(b => {
            if(b.x < minX || b.x > maxX || b.y < minY || b.y > maxY) {
                b.gridR = null; return; 
            }
            const cx = b.x + b.w/2;
            const cy = b.y + b.h/2;
            const c = Math.round((cx - minX) / stepX);
            const r = Math.round((cy - minY) / stepY);
            
            if(c>=0 && c<COLS && r>=0 && r<ROWS) {
                b.gridR=r; b.gridC=c; 
            } else {
                b.gridR=null; 
            }
        });
        return g;
    }

    function cloneGrid(grid) { return grid.map(r => [...r]); }

    function applyMoveToGrid(grid, move) {
        for(let r=move.r1; r<=move.r2; r++) {
            for(let c=move.c1; c<=move.c2; c++) {
                grid[r][c] = 0;
            }
        }
    }

    function generateSystemMemory() {
        for(let n in ASCII_DIGITS) {
            const art=ASCII_DIGITS[n], f=new Array(256).fill(0);
            for(let r=0;r<16;r++) for(let c=0;c<16;c++) {
                const ar=Math.floor(r/(16/7)), ac=Math.floor(c/(16/5));
                if(art[ar] && art[ar][ac]==='#') f[r*16+c]=1;
            }
            systemMemory.push({label:parseInt(n), data:f});
        }
    }

    function resetMem() {
        if(confirm("Clear memory?")) { localStorage.removeItem('sum10_pro_mem'); userMemory=[]; process(); }
    }
</script>
</body>
</html>
