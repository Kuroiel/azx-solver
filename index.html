<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sum-10 Smart Auto-Suggest</title>
    <style>
        :root { --bg: #111; --panel: #1a1a1a; --primary: #0d47a1; --success: #00c853; --warn: #ffd600; }
        body { background: var(--bg); color: #ddd; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        
        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; align-items: flex-start; }
        
        /* The Game Board View */
        .stage { position: relative; border: 2px solid #333; background: #000; display: flex; justify-content: center; align-items: center; min-width: 300px; min-height: 200px;}
        canvas { display: block; image-rendering: pixelated; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        .placeholder { color: #555; pointer-events: none; }

        /* Controls */
        .panel { width: 320px; background: var(--panel); padding: 20px; border-radius: 8px; box-shadow: 0 4px 15px rgba(0,0,0,0.5); }
        .status { font-weight: bold; margin-bottom: 10px; color: var(--warn); min-height: 1.2em; }
        
        .btn { width: 100%; padding: 12px; margin-top: 10px; border: none; font-weight: bold; cursor: pointer; color: white; background: #333; border-radius: 4px; transition: 0.1s;}
        .btn-solve { background: var(--success); color: #000; }
        .btn-solve:hover { transform: scale(1.02); }
        .btn:disabled { opacity: 0.3; cursor: default; transform: none; }

        .slider-box { margin: 15px 0; padding: 10px; background: #222; border-radius: 4px; border: 1px solid #333; }
        .slider-label { display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa; margin-bottom: 5px; }

        /* Training Modal */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 1000; }
        .modal-box { background: #222; padding: 30px; border-radius: 10px; text-align: center; border: 1px solid #555; width: 280px; }
        .train-img { width: 64px; height: 64px; border: 2px solid #555; margin: 15px auto; display: block; image-rendering: pixelated; }
        
        .guess-text { color: var(--success); font-size: 0.9em; margin-bottom: 5px; min-height: 1.2em; }
        .train-input { font-size: 30px; width: 80px; text-align: center; background: #000; color: #fff; border: 1px solid #555; padding: 5px; border-radius: 4px; }
        
        .modal-actions { display: flex; gap: 10px; margin-top: 15px; }
        .btn-ignore { background: #d32f2f; font-size: 0.8em; }
        .btn-save { background: var(--success); color:black; }

        .memory-stats { font-size: 0.7em; color: #555; text-align: center; margin-top: 20px; cursor: pointer; }
    </style>
</head>
<body>

    <h2 style="color:#29b6f6; margin-top:0;">why hard</h2>
    
    <div class="container">
        <!-- Main Image -->
        <div class="stage">
            <span class="placeholder">Paste Screenshot (Ctrl+V)</span>
            <canvas id="mainCanvas" style="display:none"></canvas>
            <canvas id="overlayCanvas"></canvas>
        </div>

        <!-- Controls -->
        <div class="panel">
            <div id="status" class="status">Waiting for image...</div>

            <div class="slider-box">
                <div class="slider-label"><span>Detection Sensitivity</span> <span id="threshVal">180</span></div>
                <input type="range" id="threshold" min="100" max="250" value="180" style="width:100%" oninput="process()">
                <div style="font-size:0.7em; color:#666; margin-top:5px;">Move slider until you see clean white numbers below.</div>
            </div>

            <button id="solveBtn" class="btn btn-solve" disabled onclick="confirmMove()">SOLVE</button>
            
            <div class="memory-stats" onclick="resetMem()">
                [ Memory Size: <span id="memSize">0</span> templates ]<br>
                (Click to Reset)
            </div>
        </div>
    </div>

    <!-- Training Modal -->
    <div id="trainModal" class="modal">
        <div class="modal-box">
            <h3 style="margin:0 0 10px 0;">New Shape</h3>
            
            <!-- What Computer Sees -->
            <canvas id="trainCanvas" class="train-img"></canvas>
            
            <div id="guessText" class="guess-text"></div>
            <input type="number" id="trainInput" class="train-input" min="0" max="9">
            
            <div class="modal-actions">
                <button class="btn btn-ignore" onclick="ignoreShape()">IGNORE</button>
                <button class="btn btn-save" onclick="saveShape()">ENTER</button>
            </div>
            <div style="font-size:0.7em; color:#666; margin-top:10px;">Press Enter to confirm</div>
        </div>
    </div>

<script>
    // --- CONFIG ---
    const ROWS = 15;
    const COLS = 10;
    const NORM_SIZE = 16; 
    
    // --- STATE ---
    let srcImg = null;
    let gridData = [];
    let blobs = [];
    let trainingQueue = [];
    let currentBest = null;
    let memory = JSON.parse(localStorage.getItem('sum10_suggest_mem')) || [];

    // --- INIT ---
    updateMemStats();

    // --- PASTE HANDLER ---
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => { srcImg = img; process(); };
            }
        }
    });

    // --- PROCESSING PIPELINE ---
    function process() {
        if(!srcImg) return;
        document.querySelector('.placeholder').style.display = 'none';

        const thresh = parseInt(document.getElementById('threshold').value);
        document.getElementById('threshVal').innerText = thresh;

        const cvs = document.getElementById('mainCanvas');
        const ctx = cvs.getContext('2d');
        const ovl = document.getElementById('overlayCanvas');
        
        cvs.style.display = 'block';
        cvs.width = srcImg.width; cvs.height = srcImg.height;
        ovl.width = srcImg.width; ovl.height = srcImg.height;

        // Draw & Threshold
        ctx.drawImage(srcImg, 0, 0);
        
        // 1. Detect Blobs
        const rawData = ctx.getImageData(0,0,cvs.width,cvs.height);
        blobs = detectBlobs(rawData, cvs.width, cvs.height, thresh);

        // 2. Map to Grid
        gridData = mapBlobsToGrid(blobs);

        // 3. Recognize
        trainingQueue = [];
        let recognized = 0;

        blobs.forEach(b => {
            if(b.gridR === null) return;

            // Extract features
            b.feature = extractFeature(ctx, b);
            
            // Find NEAREST match
            const bestMatch = findNearestMatch(b.feature);
            
            // Decision Logic
            // If error is very low (< 10 pixels different out of 256), auto-accept
            if(bestMatch && bestMatch.error < 15) {
                if(bestMatch.label === -1) {
                    b.isGarbage = true; // Auto-ignore garbage
                } else {
                    gridData[b.gridR][b.gridC] = bestMatch.label;
                    b.label = bestMatch.label;
                    recognized++;
                }
            } else {
                // Not sure enough -> Ask user (but provide the best guess!)
                b.bestGuess = bestMatch; 
                trainingQueue.push(b);
            }
        });

        // 4. Update UI
        drawOverlay();

        if(trainingQueue.length > 0) {
            document.getElementById('status').innerText = `Needs Input: ${trainingQueue.length} items.`;
            startTraining();
        } else if(recognized > 0) {
            document.getElementById('status').innerText = `Ready. Found ${recognized} numbers.`;
            solve();
        } else {
            document.getElementById('status').innerText = "No numbers found. Check slider.";
        }
    }

    // --- BLOB DETECTION ---
    function detectBlobs(imgData, w, h, threshold) {
        const d = imgData.data;
        const visited = new Uint8Array(w * h);
        const results = [];

        for(let i=0; i<w*h; i++) {
            if(visited[i]) continue;
            // Brightness check (R+G+B)/3
            if((d[i*4]+d[i*4+1]+d[i*4+2])/3 > threshold) {
                let stack = [i];
                visited[i] = 1;
                let minX=w, maxX=0, minY=h, maxY=0;
                
                while(stack.length) {
                    const c = stack.pop();
                    const cx = c % w;
                    const cy = Math.floor(c / w);
                    if(cx<minX) minX=cx; if(cx>maxX) maxX=cx;
                    if(cy<minY) minY=cy; if(cy>maxY) maxY=cy;

                    [c+1, c-1, c+w, c-w].forEach(n => {
                        if(n>=0 && n<w*h && !visited[n] && (d[n*4]+d[n*4+1]+d[n*4+2])/3 > threshold) {
                            visited[n] = 1;
                            stack.push(n);
                        }
                    });
                }
                const width = maxX-minX+1;
                const height = maxY-minY+1;
                // Basic size filter to remove dust/lines
                if(width>3 && height>6 && width<60 && height<60) {
                    results.push({x:minX, y:minY, w:width, h:height});
                }
            }
        }
        return results;
    }

    // --- FEATURE EXTRACTION ---
    function extractFeature(ctx, b) {
        // Create 16x16 normalized grid
        const tc = document.createElement('canvas');
        tc.width = NORM_SIZE; tc.height = NORM_SIZE;
        const tctx = tc.getContext('2d');
        
        // Scale blob to fit
        tctx.drawImage(ctx.canvas, b.x, b.y, b.w, b.h, 0, 0, NORM_SIZE, NORM_SIZE);
        
        // Convert to binary array
        const id = tctx.getImageData(0,0,NORM_SIZE,NORM_SIZE).data;
        const arr = [];
        for(let i=0; i<id.length; i+=4) {
            // High contrast
            arr.push(id[i] > 100 ? 1 : 0);
        }
        return arr;
    }

    // --- MATCHING ---
    function findNearestMatch(feature) {
        if(memory.length === 0) return null;
        
        let best = null;
        let minError = Infinity;

        memory.forEach(mem => {
            let error = 0;
            // Hamming distance (count different pixels)
            for(let i=0; i<feature.length; i++) {
                if(feature[i] !== mem.data[i]) error++;
            }
            if(error < minError) {
                minError = error;
                best = mem;
            }
        });

        // Return the closest thing we have, even if error is high
        return { label: best.label, error: minError };
    }

    // --- TRAINING UI ---
    function startTraining() {
        if(trainingQueue.length === 0) {
            document.getElementById('trainModal').style.display = 'none';
            updateMemStats();
            process(); // Re-run to solve
            return;
        }

        const b = trainingQueue[0];
        const modal = document.getElementById('trainModal');
        const guessTxt = document.getElementById('guessText');
        const inp = document.getElementById('trainInput');
        const c = document.getElementById('trainCanvas');

        // Draw preview
        c.width = NORM_SIZE; c.height = NORM_SIZE;
        const ctx = c.getContext('2d');
        const img = ctx.createImageData(NORM_SIZE, NORM_SIZE);
        for(let i=0; i<b.feature.length; i++) {
            const val = b.feature[i]*255;
            img.data[i*4]=val; img.data[i*4+1]=val; img.data[i*4+2]=val; img.data[i*4+3]=255;
        }
        ctx.putImageData(img,0,0);

        // AUTO-SUGGESTION LOGIC
        inp.value = '';
        guessTxt.innerText = '';
        
        if(b.bestGuess) {
            // If we have a guess, pre-fill it!
            if(b.bestGuess.label !== -1) {
                inp.value = b.bestGuess.label;
                guessTxt.innerText = `I think this is a ${b.bestGuess.label}?`;
            } else {
                guessTxt.innerText = "Looks like garbage?";
            }
        }

        modal.style.display = 'flex';
        inp.focus();
        inp.select();
    }

    function saveShape() {
        const val = parseInt(document.getElementById('trainInput').value);
        if(isNaN(val)) return;

        // Add to memory
        memory.push({ label: val, data: trainingQueue[0].feature });
        localStorage.setItem('sum10_suggest_mem', JSON.stringify(memory));
        
        trainingQueue.shift();
        startTraining();
    }

    function ignoreShape() {
        memory.push({ label: -1, data: trainingQueue[0].feature });
        localStorage.setItem('sum10_suggest_mem', JSON.stringify(memory));
        trainingQueue.shift();
        startTraining();
    }

    document.getElementById('trainInput').addEventListener("keydown", (e) => {
        if(e.key === "Enter") saveShape();
    });

    // --- GRID MAPPER ---
    function mapBlobsToGrid(rawBlobs) {
        let grid = Array(ROWS).fill().map(() => Array(COLS).fill(0));
        if(rawBlobs.length === 0) return grid;
        
        let minX=9999, maxX=0, minY=9999, maxY=0;
        rawBlobs.forEach(b => {
            if(b.x<minX) minX=b.x; if(b.x+b.w>maxX) maxX=b.x+b.w;
            if(b.y<minY) minY=b.y; if(b.y+b.h>maxY) maxY=b.y+b.h;
        });

        const totalW = maxX-minX;
        const totalH = maxY-minY;
        const cellW = totalW/9.5;
        const cellH = totalH/14.5;

        rawBlobs.forEach(b => {
            const cx = b.x+b.w/2;
            const cy = b.y+b.h/2;
            const c = Math.round((cx-minX)/(totalW/9));
            const r = Math.round((cy-minY)/(totalH/14));
            if(c>=0 && c<COLS && r>=0 && r<ROWS) {
                b.gridR = r; b.gridC = c;
            } else {
                b.gridR = null;
            }
        });
        return grid;
    }

    // --- SOLVER ---
    function solve() {
        let best = null;
        let maxScore = -1;
        
        for (let r1 = 0; r1 < ROWS; r1++) {
            for (let c1 = 0; c1 < COLS; c1++) {
                for (let r2 = r1; r2 < ROWS; r2++) {
                    for (let c2 = c1; c2 < COLS; c2++) {
                        let sum = 0; let count = 0;
                        for(let i=r1; i<=r2; i++){
                            for(let j=c1; j<=c2; j++){
                                let v = gridData[i][j];
                                sum+=v; if(v>0) count++;
                            }
                        }
                        if(sum===10 && count>0) {
                            // Score: Higher count is better. Area breaks ties.
                            let score = (count*1000) + ((r2-r1)*(c2-c1));
                            if(score > maxScore) {
                                maxScore = score;
                                best = { r1,c1,r2,c2,count };
                            }
                        }
                    }
                }
            }
        }

        currentBest = best;
        const btn = document.getElementById('solveBtn');
        if(best) {
            document.getElementById('status').innerText = `Best Move: Clears ${best.count} tiles.`;
            btn.disabled = false;
            btn.innerText = "MATCH DONE (Next)";
            drawOverlay(best);
        } else {
            document.getElementById('status').innerText = "No moves available.";
            btn.disabled = true;
            btn.innerText = "NO MOVES";
            drawOverlay();
        }
    }

    function drawOverlay(highlight=null) {
        const cvs = document.getElementById('overlayCanvas');
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0,0,cvs.width,cvs.height);

        // Draw recognized numbers
        blobs.forEach(b => {
            if(b.label && b.label !== -1) {
                ctx.fillStyle = "#00c853";
                ctx.font = "bold 12px monospace";
                ctx.fillText(b.label, b.x, b.y-2);
                ctx.strokeStyle = "rgba(0,255,0,0.3)";
                ctx.strokeRect(b.x, b.y, b.w, b.h);
            }
        });

        // Highlight Move
        if(highlight) {
            let minX=9999, maxX=0, minY=9999, maxY=0;
            let found = false;
            blobs.forEach(b => {
                if(b.gridR>=highlight.r1 && b.gridR<=highlight.r2 && b.gridC>=highlight.c1 && b.gridC<=highlight.c2 && b.label>0) {
                    if(b.x<minX) minX=b.x; if(b.x+b.w>maxX) maxX=b.x+b.w;
                    if(b.y<minY) minY=b.y; if(b.y+b.h>maxY) maxY=b.y+b.h;
                    found=true;
                }
            });
            if(found) {
                ctx.strokeStyle = "#00e676";
                ctx.lineWidth = 4;
                ctx.strokeRect(minX-4, minY-4, (maxX-minX)+8, (maxY-minY)+8);
                ctx.fillStyle = "rgba(0, 230, 118, 0.3)";
                ctx.fillRect(minX-4, minY-4, (maxX-minX)+8, (maxY-minY)+8);
            }
        }
    }

    function confirmMove() {
        if(!currentBest) return;
        for(let r=currentBest.r1; r<=currentBest.r2; r++) {
            for(let c=currentBest.c1; c<=currentBest.c2; c++) {
                gridData[r][c] = 0;
            }
        }
        blobs = blobs.filter(b => !(b.gridR>=currentBest.r1 && b.gridR<=currentBest.r2 && b.gridC>=currentBest.c1 && b.gridC<=currentBest.c2));
        solve();
    }

    function resetMem() {
        if(confirm("Clear all memory?")) {
            localStorage.removeItem('sum10_suggest_mem');
            location.reload();
        }
    }
    
    function updateMemStats() {
        document.getElementById('memSize').innerText = memory.length;
    }
</script>
</body>
</html>
