<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bucket Match Solver</title>
    <style>
        body { font-family: 'Courier New', monospace; background: #222; color: #ddd; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        
        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        
        /* The Visuals */
        .stage { position: relative; border: 4px solid #444; }
        canvas { display: block; image-rendering: pixelated; } /* Crucial for pixel art */
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }

        /* Controls */
        .panel { width: 300px; background: #333; padding: 20px; border-radius: 8px; }
        
        .status { color: #ffeb3b; min-height: 1.5em; margin-bottom: 10px; font-weight: bold; }
        
        .btn { width: 100%; padding: 15px; background: #555; border: none; color: white; font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 10px; }
        .btn.active { background: #00e676; color: black; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        /* The "Brain" View - Shows user what the PC sees */
        .brain-grid { display: grid; grid-template-columns: repeat(10, 1fr); gap: 1px; background: #000; margin-top: 20px; border: 1px solid #555; }
        .brain-cell { width: 100%; aspect-ratio: 1; background: #222; display: flex; justify-content: center; align-items: center; font-size: 10px; color: #888; position: relative; }
        .brain-cell canvas { width: 80%; height: 80%; image-rendering: pixelated; }

        /* Modal */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 100; }
        .modal-box { background: #222; padding: 30px; border: 2px solid #555; text-align: center; }
        .train-img { width: 64px; height: 64px; border: 1px solid #777; margin: 15px; image-rendering: pixelated; }
        .train-input { font-size: 30px; width: 60px; text-align: center; background: #000; color: white; border: 1px solid #555; }

        .slider-label { display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa; margin-top: 15px;}
    </style>
</head>
<body>

    <h2>minigame</h2>
    <div style="margin-bottom:10px; color:#aaa; font-size:0.9em;">
        1. Paste Image (Ctrl+V). Crop tightly to the grid if possible.<br>
        2. If numbers aren't visible in "Computer Vision" below, adjust Brightness Slider.
    </div>

    <div class="container">
        <!-- Main Image -->
        <div class="stage">
            <canvas id="imgCanvas"></canvas>
            <canvas id="overlayCanvas"></canvas>
        </div>

        <!-- Controls -->
        <div class="panel">
            <div id="status" class="status">Waiting for image...</div>
            
            <button id="solveBtn" class="btn" disabled onclick="confirmMove()">SOLVE</button>

            <div class="slider-label"><span>Brightness Filter</span> <span id="threshVal">160</span></div>
            <input type="range" id="threshSlider" min="100" max="250" value="160" style="width:100%" oninput="reprocess()">
            
            <div style="margin-top:20px; border-top:1px solid #555; padding-top:10px;">
                <small>Computer Vision Preview:</small>
                <div id="brainGrid" class="brain-grid"></div>
            </div>
            
            <button style="margin-top:20px; font-size:12px; padding:5px; background:none;" onclick="resetMem()">[ Reset Memory ]</button>
        </div>
    </div>

    <!-- Training Modal -->
    <div id="trainModal" class="modal">
        <div class="modal-box">
            <h3>Teach me this number</h3>
            <canvas id="trainCanvas" class="train-img"></canvas>
            <br>
            <input type="number" id="trainInput" class="train-input" min="0" max="9">
            <br><br>
            <button class="btn active" style="padding:10px;" onclick="saveTraining()">SAVE</button>
        </div>
    </div>

<script>
    const ROWS = 15;
    const COLS = 10;
    const TEMPLATE_SIZE = 20; // We normalize all numbers to 20x20 pixels
    
    let srcImage = null;
    let gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let cellFeatures = []; // Stores the pixel data for each cell
    let templates = JSON.parse(localStorage.getItem('bucket_templates_v2')) || [];
    let trainingQueue = [];
    let currentBest = null;

    // --- PASTE HANDLER ---
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => { srcImage = img; reprocess(); };
            }
        }
    });

    function reprocess() {
        if(!srcImage) return;

        const thresh = parseInt(document.getElementById('threshSlider').value);
        document.getElementById('threshVal').innerText = thresh;

        // 1. Setup Canvas
        const canvas = document.getElementById('imgCanvas');
        const overlay = document.getElementById('overlayCanvas');
        const ctx = canvas.getContext('2d');
        canvas.width = srcImage.width; canvas.height = srcImage.height;
        overlay.width = srcImage.width; overlay.height = srcImage.height;
        ctx.drawImage(srcImage, 0, 0);

        // 2. Grid Slicing
        const cellW = canvas.width / COLS;
        const cellH = canvas.height / ROWS;
        const brainGrid = document.getElementById('brainGrid');
        brainGrid.innerHTML = '';
        cellFeatures = [];

        // 3. Process Each Cell
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                
                // Extract Cell (Center 60% to avoid bucket edges)
                const padX = cellW * 0.2;
                const padY = cellH * 0.2; // Numbers are usually top/center aligned in bucket, but safe to crop center
                
                // Get raw pixels of the cell
                const imgData = ctx.getImageData(
                    (c*cellW) + padX, (r*cellH) + padY, 
                    cellW - (padX*2), cellH - (padY*2)
                );
                
                // Process: Threshold -> Center -> Normalize
                const featureCanvas = processCellToFeature(imgData, thresh);
                
                // Add to visual debug
                const div = document.createElement('div');
                div.className = 'brain-cell';
                div.id = `brain-${r}-${c}`;
                // Append the processed canvas so user sees what PC sees
                const debugCanv = document.createElement('canvas');
                debugCanv.width = TEMPLATE_SIZE; debugCanv.height = TEMPLATE_SIZE;
                debugCanv.getContext('2d').drawImage(featureCanvas, 0, 0);
                div.appendChild(debugCanv);
                brainGrid.appendChild(div);

                // Store for matching
                cellFeatures.push({ r, c, canvas: featureCanvas });
            }
        }

        // 4. Identify Numbers
        trainingQueue = [];
        gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));

        cellFeatures.forEach(item => {
            const match = findMatch(item.canvas);
            if (match) {
                gridData[item.r][item.c] = match.label;
                // Show recognized number in debug grid
                const label = document.createElement('span');
                label.innerText = match.label;
                label.style.cssText = "position:absolute; bottom:0; right:0; color:#0f0; font-weight:bold; background:rgba(0,0,0,0.7);";
                document.getElementById(`brain-${item.r}-${item.c}`).appendChild(label);
            } else {
                // Check if it's empty (black)
                if(!isEmpty(item.canvas)) {
                    trainingQueue.push(item);
                }
            }
        });

        if(trainingQueue.length > 0) {
            startTraining();
        } else {
            solve();
        }
    }

    // --- THE CORE LOGIC: IMAGE NORMALIZATION ---
    function processCellToFeature(imgData, threshold) {
        // 1. Thresholding (Turn pixels Black or White)
        const w = imgData.width;
        const h = imgData.height;
        const d = imgData.data;
        
        let minX = w, maxX = 0, minY = h, maxY = 0;
        let hasPixels = false;

        // Find bounding box of WHITE pixels
        for(let i=0; i<d.length; i+=4) {
            const bright = (d[i] + d[i+1] + d[i+2]) / 3;
            if(bright > threshold) {
                const idx = i/4;
                const x = idx % w;
                const y = Math.floor(idx / w);
                
                if(x < minX) minX = x;
                if(x > maxX) maxX = x;
                if(y < minY) minY = y;
                if(y > maxY) maxY = y;
                hasPixels = true;
            }
        }

        // Create normalized 20x20 canvas
        const out = document.createElement('canvas');
        out.width = TEMPLATE_SIZE; out.height = TEMPLATE_SIZE;
        const ctx = out.getContext('2d');
        ctx.fillStyle = "black";
        ctx.fillRect(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE);

        if(!hasPixels) return out; // Return empty black square

        // 2. Draw the cut-out number into the center of the 20x20 square
        // We assume the pixel art number isn't larger than 20x20
        const contentW = maxX - minX + 1;
        const contentH = maxY - minY + 1;

        // Calculate offset to center it
        const offX = Math.floor((TEMPLATE_SIZE - contentW) / 2);
        const offY = Math.floor((TEMPLATE_SIZE - contentH) / 2);

        // Create a temp canvas for the cropped content
        const temp = document.createElement('canvas');
        temp.width = w; temp.height = h;
        const tCtx = temp.getContext('2d');
        tCtx.putImageData(imgData, 0, 0);

        // Draw just the white part into the center of the output
        ctx.drawImage(temp, minX, minY, contentW, contentH, offX, offY, contentW, contentH);
        
        // Final Threshold pass to ensure clean B&W lines (removes anti-aliasing gray)
        const finalData = ctx.getImageData(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE);
        for(let i=0; i<finalData.data.length; i+=4) {
            const val = finalData.data[i];
            const bin = val > 50 ? 255 : 0; // Strict binary
            finalData.data[i] = bin;
            finalData.data[i+1] = bin;
            finalData.data[i+2] = bin;
        }
        ctx.putImageData(finalData, 0, 0);

        return out;
    }

    function isEmpty(canvas) {
        const d = canvas.getContext('2d').getImageData(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE).data;
        for(let i=0; i<d.length; i+=4) {
            if(d[i] > 128) return false;
        }
        return true;
    }

    // --- MATCHING ---
    function findMatch(inputCanvas) {
        if(templates.length === 0) return null;
        
        const inputData = inputCanvas.getContext('2d').getImageData(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE).data;
        
        for(let t of templates) {
            // Compare pixel by pixel
            let diff = 0;
            for(let i=0; i<inputData.length; i+=4) {
                // If pixel mismatch (one is white, one is black)
                if(inputData[i] !== t.data[i]) {
                    diff++;
                }
            }
            
            // Allow very slight error (pixel flicker)
            if(diff < 10) return t; // 10 pixels different max
        }
        return null;
    }

    // --- TRAINING ---
    function startTraining() {
        if(trainingQueue.length === 0) {
            document.getElementById('trainModal').style.display = 'none';
            localStorage.setItem('bucket_templates_v2', JSON.stringify(templates));
            reprocess();
            return;
        }

        const item = trainingQueue[0];
        const modal = document.getElementById('trainModal');
        const tCanvas = document.getElementById('trainCanvas');
        const input = document.getElementById('trainInput');

        tCanvas.width = TEMPLATE_SIZE; tCanvas.height = TEMPLATE_SIZE;
        tCanvas.getContext('2d').drawImage(item.canvas, 0, 0);
        
        // Scale up for visibility in CSS
        
        modal.style.display = 'flex';
        input.value = '';
        input.focus();
    }

    function saveTraining() {
        const val = parseInt(document.getElementById('trainInput').value);
        if(isNaN(val)) return;

        // Save pixels
        const canvas = trainingQueue[0].canvas;
        const pixels = canvas.getContext('2d').getImageData(0,0,TEMPLATE_SIZE,TEMPLATE_SIZE).data;
        
        // Store just the Red channel since it's B&W
        const storedData = []; // Full array for easier comparison
        for(let i=0; i<pixels.length; i++) storedData.push(pixels[i]);

        templates.push({ label: val, data: storedData });
        
        // Remove ALL similar items from queue immediately (Bulk Solve)
        const currentItemCanvas = trainingQueue[0].canvas;
        trainingQueue = trainingQueue.filter(q => {
            // If q looks like the one we just trained, skip it
            const match = findMatch(q.canvas);
            return match === null; // Keep if we still don't know it
        });

        startTraining();
    }

    document.getElementById('trainInput').addEventListener("keydown", (e) => {
        if(e.key === "Enter") saveTraining();
    });

    // --- SOLVING ---
    function solve() {
        const btn = document.getElementById('solveBtn');
        let best = null;
        let maxScore = -1;

        for (let r1 = 0; r1 < ROWS; r1++) {
            for (let c1 = 0; c1 < COLS; c1++) {
                for (let r2 = r1; r2 < ROWS; r2++) {
                    for (let c2 = c1; c2 < COLS; c2++) {
                        let sum = 0;
                        let count = 0;
                        for(let i=r1; i<=r2; i++){
                            for(let j=c1; j<=c2; j++){
                                let v = gridData[i][j];
                                sum += v;
                                if(v>0) count++;
                            }
                        }
                        if(sum === 10 && count > 0) {
                            let score = (count * 1000) + ((r2-r1)*(c2-c1));
                            if(score > maxScore) {
                                maxScore = score;
                                best = { r1, c1, r2, c2, count };
                            }
                        }
                    }
                }
            }
        }

        currentBest = best;
        if(best) {
            document.getElementById('status').innerText = `Best Move: Clears ${best.count} buckets!`;
            btn.innerHTML = "MATCH DONE (Find Next)";
            btn.className = "btn active";
            btn.disabled = false;
            highlight(best);
        } else {
            document.getElementById('status').innerText = "No moves found.";
            btn.innerText = "NO MOVES";
            btn.className = "btn";
            btn.disabled = true;
        }
    }

    function highlight(m) {
        const ctx = document.getElementById('overlayCanvas').getContext('2d');
        const w = ctx.canvas.width / COLS;
        const h = ctx.canvas.height / ROWS;
        
        ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);
        
        const x = m.c1 * w;
        const y = m.r1 * h;
        const rw = (m.c2 - m.c1 + 1) * w;
        const rh = (m.r2 - m.r1 + 1) * h;

        ctx.strokeStyle = "#00e676";
        ctx.lineWidth = 4;
        ctx.strokeRect(x, y, rw, rh);
        ctx.fillStyle = "rgba(0, 230, 118, 0.3)";
        ctx.fillRect(x, y, rw, rh);
    }

    function confirmMove() {
        if(!currentBest) return;
        for(let r=currentBest.r1; r<=currentBest.r2; r++) {
            for(let c=currentBest.c1; c<=currentBest.c2; c++) {
                gridData[r][c] = 0;
            }
        }
        solve();
    }

    function resetMem() {
        if(confirm("Clear memory?")) {
            localStorage.removeItem('bucket_templates_v2');
            location.reload();
        }
    }
</script>
</body>
</html>
