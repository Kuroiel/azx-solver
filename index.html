<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sum-10 Adaptive Solver</title>
    <style>
        body { background: #1a1a1a; color: #ddd; font-family: sans-serif; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        
        .layout { display: flex; gap: 20px; justify-content: center; flex-wrap: wrap; }
        
        /* The Stage */
        .stage { position: relative; border: 2px solid #555; background: #000; }
        canvas { display: block; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        /* Controls */
        .panel { width: 320px; background: #2d2d2d; padding: 20px; border-radius: 8px; }
        
        .status { color: #ffeb3b; font-weight: bold; margin-bottom: 10px; min-height: 1.2em; }
        
        .btn { width: 100%; padding: 12px; margin-top: 10px; border: none; font-weight: bold; cursor: pointer; color: white; background: #444; }
        .btn.primary { background: #007bff; }
        .btn.primary:hover { background: #0056b3; }
        .btn:disabled { opacity: 0.5; cursor: default; }

        .slider-box { margin: 15px 0; padding: 10px; background: #222; border-radius: 4px; border: 1px solid #444; }
        .slider-label { display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa; margin-bottom: 5px; }
        
        /* Training Modal */
        .modal { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); display: none; justify-content: center; align-items: center; z-index: 999; }
        .modal-content { background: #333; padding: 30px; border-radius: 8px; text-align: center; border: 1px solid #666; }
        .train-img { width: 60px; height: 60px; image-rendering: pixelated; border: 2px solid #fff; margin: 15px; }
        .train-input { font-size: 24px; width: 60px; text-align: center; background: #000; color: #fff; border: 1px solid #555; }
    </style>
</head>
<body>

    <h2>doro</h2>
    <div style="font-size:0.85em; color:#888; margin-bottom:15px; text-align:center;">
        Works with off-center screenshots & borders.<br>
        1. Paste Image &nbsp;|&nbsp; 2. Adjust slider until ONLY numbers are white &nbsp;|&nbsp; 3. Teach & Solve
    </div>

    <div class="layout">
        <!-- Main Display -->
        <div class="stage">
            <canvas id="mainCanvas"></canvas>
            <canvas id="overlayCanvas"></canvas>
        </div>

        <!-- Controls -->
        <div class="panel">
            <div id="status" class="status">Paste screenshot to begin...</div>

            <!-- View Toggle -->
            <div style="font-size:0.8em; margin-bottom:5px;">Preview Mode:</div>
            <select id="viewMode" style="width:100%; padding:5px; background:#444; color:white; border:none;" onchange="updateView()">
                <option value="original">Original Image</option>
                <option value="threshold">Computer Vision (Contrast)</option>
            </select>

            <div class="slider-box">
                <div class="slider-label"><span>Sensitivity (Threshold)</span> <span id="threshVal">200</span></div>
                <input type="range" id="threshold" min="100" max="250" value="200" style="width:100%" oninput="processImage()">
                <div style="font-size:0.7em; color:#777; margin-top:5px;">Slide RIGHT to remove bucket rims.<br>Slide LEFT if numbers disappear.</div>
            </div>

            <button id="solveBtn" class="btn primary" disabled onclick="confirmMove()">SOLVE BOARD</button>
            <button class="btn" onclick="resetMemory()" style="margin-top:20px; font-size:0.8em; background:none;">[ Reset Learned Numbers ]</button>
        </div>
    </div>

    <!-- Modal -->
    <div id="trainModal" class="modal">
        <div class="modal-content">
            <h3>New Shape Detected</h3>
            <p style="color:#aaa; font-size:0.8em;">Type the number seen below</p>
            <canvas id="trainCanvas" class="train-img"></canvas>
            <br>
            <input type="number" id="trainInput" class="train-input" min="0" max="9">
            <br><br>
            <button class="btn primary" onclick="saveTraining()">Save</button>
        </div>
    </div>

<script>
    // --- SETTINGS ---
    const ROWS = 15;
    const COLS = 10;
    const NORM_SIZE = 16; // Normalize numbers to 16x16px
    
    // --- STATE ---
    let srcImg = null;
    let gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    let detectedBlobs = [];
    let trainingQueue = [];
    let memory = JSON.parse(localStorage.getItem('sum10_memory')) || [];
    let currentBestMove = null;

    // --- PASTE HANDLER ---
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => { srcImg = img; processImage(); };
            }
        }
    });

    // --- MAIN PIPELINE ---
    function processImage() {
        if(!srcImg) return;
        
        const thresh = parseInt(document.getElementById('threshold').value);
        document.getElementById('threshVal').innerText = thresh;

        const cvs = document.getElementById('mainCanvas');
        const ctx = cvs.getContext('2d');
        const ovl = document.getElementById('overlayCanvas');
        
        // Resize
        cvs.width = srcImg.width; cvs.height = srcImg.height;
        ovl.width = srcImg.width; ovl.height = srcImg.height;

        // Draw Original
        ctx.drawImage(srcImg, 0, 0);

        // 1. Detect Blobs (The Numbers)
        const imgData = ctx.getImageData(0, 0, cvs.width, cvs.height);
        const blobs = findBlobs(imgData, thresh);

        // 2. Map Blobs to Grid (Auto-Alignment)
        detectedBlobs = mapBlobsToGrid(blobs, cvs.width, cvs.height);

        // 3. Identification (Pattern Matching)
        trainingQueue = [];
        gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));

        detectedBlobs.forEach(b => {
            // Extract normalized feature (16x16 pixel array)
            const feature = extractFeature(ctx, b);
            
            // Compare against memory
            const match = findBestMatch(feature);
            
            if(match) {
                gridData[b.r][b.c] = match.label;
                b.label = match.label; // For debug drawing
            } else {
                trainingQueue.push({ blob: b, feature: feature });
            }
        });

        // Update View
        updateView();

        // Status Update
        if(detectedBlobs.length < 5) {
            document.getElementById('status').innerText = "⚠️ No numbers found. Adjust Sensitivity!";
            document.getElementById('solveBtn').disabled = true;
        } else if(trainingQueue.length > 0) {
            document.getElementById('status').innerText = `Found ${detectedBlobs.length} items. ${trainingQueue.length} unknown.`;
            startTraining();
        } else {
            document.getElementById('status').innerText = `Grid recognized. Ready to solve.`;
            solve();
        }
    }

    // --- STEP 1: BLOB DETECTION (FLOOD FILL) ---
    function findBlobs(imgData, threshold) {
        const w = imgData.width;
        const h = imgData.height;
        const d = imgData.data;
        const visited = new Uint8Array(w * h);
        const blobs = [];

        // Scan pixels
        for(let i=0; i<w*h; i++) {
            if(visited[i]) continue;
            
            // Check Brightness (RGB average)
            const r=d[i*4], g=d[i*4+1], b=d[i*4+2];
            const bright = (r+g+b)/3;

            if(bright > threshold) {
                // Found a bright pixel! Flood fill to find the whole shape.
                let stack = [i];
                visited[i] = 1;
                let minX=w, maxX=0, minY=h, maxY=0;
                let pixelCount = 0;

                while(stack.length) {
                    const curr = stack.pop();
                    const cx = curr % w;
                    const cy = Math.floor(curr / w);
                    
                    if(cx < minX) minX = cx;
                    if(cx > maxX) maxX = cx;
                    if(cy < minY) minY = cy;
                    if(cy > maxY) maxY = cy;
                    pixelCount++;

                    // Check 4 neighbors
                    const neighbors = [curr+1, curr-1, curr+w, curr-w];
                    for(let n of neighbors) {
                        if(n>=0 && n<w*h && !visited[n]) {
                            const nr=d[n*4], ng=d[n*4+1], nb=d[n*4+2];
                            if((nr+ng+nb)/3 > threshold) {
                                visited[n] = 1;
                                stack.push(n);
                            }
                        }
                    }
                }

                // Filter Noise: Must be big enough to be a number
                const width = maxX - minX + 1;
                const height = maxY - minY + 1;
                if(width > 4 && height > 8 && pixelCount > 15) {
                    blobs.push({ x: minX, y: minY, w: width, h: height });
                }
            }
        }
        return blobs;
    }

    // --- STEP 2: AUTO-GRID MAPPING ---
    function mapBlobsToGrid(blobs, imgW, imgH) {
        if(blobs.length === 0) return [];

        // 1. Find the bounding box of the entire grid content
        let gridMinX = Math.min(...blobs.map(b => b.x));
        let gridMaxX = Math.max(...blobs.map(b => b.x + b.w));
        let gridMinY = Math.min(...blobs.map(b => b.y));
        let gridMaxY = Math.max(...blobs.map(b => b.y + b.h));

        // 2. Estimate Cell Size
        const totalW = gridMaxX - gridMinX;
        const totalH = gridMaxY - gridMinY;
        
        // We assume the blobs detected span roughly the whole 10x15 grid
        // The average spacing is TotalWidth / 9 (since 10 items have 9 gaps)
        const avgCellW = totalW / 9.5; // Divide by slightly less than 10 to account for width of char
        const avgCellH = totalH / 14.5;

        // 3. Assign row/col to each blob based on relative position
        const mapped = [];
        blobs.forEach(b => {
            const centerX = b.x + b.w/2;
            const centerY = b.y + b.h/2;
            
            // Calculate index
            let c = Math.round((centerX - gridMinX) / (totalW / 9)); 
            let r = Math.round((centerY - gridMinY) / (totalH / 14));

            // Clamp to grid size
            if(c >= 0 && c < COLS && r >= 0 && r < ROWS) {
                b.r = r;
                b.c = c;
                mapped.push(b);
            }
        });
        return mapped;
    }

    // --- STEP 3: FEATURE EXTRACTION (Normalize) ---
    function extractFeature(ctx, blob) {
        // Create 16x16 canvas
        const tC = document.createElement('canvas');
        tC.width = NORM_SIZE; tC.height = NORM_SIZE;
        const tCtx = tC.getContext('2d');
        
        // Draw the blob, stretched to fit 16x16
        // This removes size differences (small '1' vs big '1')
        tCtx.drawImage(ctx.canvas, blob.x, blob.y, blob.w, blob.h, 0, 0, NORM_SIZE, NORM_SIZE);
        
        // Convert to simple binary array (0 or 1)
        const d = tCtx.getImageData(0,0,NORM_SIZE,NORM_SIZE).data;
        const features = [];
        for(let i=0; i<d.length; i+=4) {
            // Since source was already thresholded mostly, just take R channel
            features.push(d[i] > 100 ? 1 : 0);
        }
        return { data: features, debugCanvas: tC };
    }

    function findBestMatch(feature) {
        if(memory.length === 0) return null;
        
        let best = null;
        let minDiff = 9999;
        
        memory.forEach(mem => {
            // Count differing pixels
            let diff = 0;
            for(let i=0; i<feature.data.length; i++) {
                if(feature.data[i] !== mem.data[i]) diff++;
            }
            
            if(diff < minDiff) {
                minDiff = diff;
                best = mem;
            }
        });

        // Tolerance: Allow up to 10% pixel mismatch (approx 25 pixels in 256 total)
        if(minDiff < 30) return best;
        return null;
    }

    // --- TRAINING UI ---
    function startTraining() {
        if(trainingQueue.length === 0) {
            document.getElementById('trainModal').style.display = 'none';
            // Save to browser
            localStorage.setItem('sum10_memory', JSON.stringify(memory));
            // Reprocess to clear queue
            processImage();
            return;
        }

        const item = trainingQueue[0];
        const modal = document.getElementById('trainModal');
        const c = document.getElementById('trainCanvas');
        const inp = document.getElementById('trainInput');
        
        // Show the normalized view (what the computer sees)
        c.width = NORM_SIZE; c.height = NORM_SIZE;
        c.getContext('2d').putImageData(item.feature.debugCanvas.getContext('2d').getImageData(0,0,16,16),0,0);
        
        modal.style.display = 'flex';
        inp.value = '';
        inp.focus();
    }

    function saveTraining() {
        const val = parseInt(document.getElementById('trainInput').value);
        if(isNaN(val)) return;

        memory.push({ label: val, data: trainingQueue[0].feature.data });
        
        // Attempt to auto-solve remaining queue with new knowledge
        const newData = trainingQueue[0].feature.data;
        trainingQueue.shift(); // Remove current
        
        startTraining();
    }

    document.getElementById('trainInput').addEventListener("keydown", (e) => {
        if(e.key === "Enter") saveTraining();
    });

    // --- SOLVER ---
    function solve() {
        const btn = document.getElementById('solveBtn');
        let best = null;
        let maxScore = -1;

        for(let r1=0; r1<ROWS; r1++) {
            for(let c1=0; c1<COLS; c1++) {
                for(let r2=r1; r2<ROWS; r2++) {
                    for(let c2=c1; c2<COLS; c2++) {
                        let s = 0;
                        let c = 0;
                        for(let i=r1; i<=r2; i++) {
                            for(let j=c1; j<=c2; j++) {
                                let v = gridData[i][j];
                                s += v;
                                if(v>0) c++;
                            }
                        }
                        if(s === 10 && c > 0) {
                            let score = (c * 1000) + ((r2-r1)*(c2-c1));
                            if(score > maxScore) {
                                maxScore = score;
                                best = {r1,c1,r2,c2,c};
                            }
                        }
                    }
                }
            }
        }

        currentBestMove = best;
        
        if(best) {
            document.getElementById('status').innerText = `Best Move: Clears ${best.c} tiles`;
            btn.disabled = false;
            highlight(best);
        } else {
            document.getElementById('status').innerText = "No moves found.";
            btn.disabled = true;
        }
    }

    function highlight(m) {
        // Redraw detected blobs
        updateView();
        const ctx = document.getElementById('overlayCanvas').getContext('2d');
        
        // Find bounds of items in grid range
        let minX=9999, maxX=0, minY=9999, maxY=0;
        let found = false;
        
        detectedBlobs.forEach(b => {
            if(b.r >= m.r1 && b.r <= m.r2 && b.c >= m.c1 && b.c <= m.c2) {
                if(b.x < minX) minX = b.x;
                if(b.x+b.w > maxX) maxX = b.x+b.w;
                if(b.y < minY) minY = b.y;
                if(b.y+b.h > maxY) maxY = b.y+b.h;
                found = true;
            }
        });

        if(found) {
            // Draw nice box
            const pad = 5;
            ctx.strokeStyle = "#00ff00";
            ctx.lineWidth = 4;
            ctx.strokeRect(minX-pad, minY-pad, (maxX-minX)+pad*2, (maxY-minY)+pad*2);
            ctx.fillStyle = "rgba(0,255,0,0.3)";
            ctx.fillRect(minX-pad, minY-pad, (maxX-minX)+pad*2, (maxY-minY)+pad*2);
        }
    }

    function confirmMove() {
        if(!currentBestMove) return;
        // Clear data
        for(let r=currentBestMove.r1; r<=currentBestMove.r2; r++) {
            for(let c=currentBestMove.c1; c<=currentBestMove.c2; c++) {
                gridData[r][c] = 0;
            }
        }
        // Remove detected blobs from list so they don't get re-read
        detectedBlobs = detectedBlobs.filter(b => 
            !(b.r >= currentBestMove.r1 && b.r <= currentBestMove.r2 && 
              b.c >= currentBestMove.c1 && b.c <= currentBestMove.c2)
        );
        solve();
    }

    function updateView() {
        const mode = document.getElementById('viewMode').value;
        const cvs = document.getElementById('mainCanvas');
        const ctx = cvs.getContext('2d');
        const ovl = document.getElementById('overlayCanvas');
        const oCtx = ovl.getContext('2d');
        
        // Clear overlay
        oCtx.clearRect(0,0,ovl.width, ovl.height);

        if(mode === 'threshold') {
            // Draw the thresholded view so user can debug
            const thresh = parseInt(document.getElementById('threshold').value);
            // Redraw source first to get data
            ctx.drawImage(srcImg, 0, 0);
            const imgData = ctx.getImageData(0,0,cvs.width,cvs.height);
            const d = imgData.data;
            for(let i=0; i<d.length; i+=4) {
                const bright = (d[i]+d[i+1]+d[i+2])/3;
                const val = bright > thresh ? 255 : 0;
                d[i] = val; d[i+1] = val; d[i+2] = val;
            }
            ctx.putImageData(imgData, 0, 0);
        } else {
            ctx.drawImage(srcImg, 0, 0);
        }

        // Draw debug boxes around detected blobs
        detectedBlobs.forEach(b => {
            oCtx.strokeStyle = "rgba(255, 0, 0, 0.5)";
            oCtx.lineWidth = 1;
            oCtx.strokeRect(b.x, b.y, b.w, b.h);
            if(b.label) {
                oCtx.fillStyle = "#0f0";
                oCtx.font = "12px sans-serif";
                oCtx.fillText(b.label, b.x, b.y-2);
            }
        });
    }

    function resetMemory() {
        localStorage.removeItem('sum10_memory');
        location.reload();
    }
</script>
</body>
</html>
