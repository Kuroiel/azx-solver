<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sum-10 Optimizer (10x16)</title>
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: #1a1a1a; color: #eee; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h1 { margin: 0 0 10px 0; color: #4db8ff; }
        p { color: #aaa; margin-bottom: 20px; font-size: 0.9em; }
        
        .container { display: flex; gap: 30px; flex-wrap: wrap; justify-content: center; align-items: flex-start; }
        
        /* The Image Area */
        .canvas-wrapper { position: relative; border: 3px solid #444; box-shadow: 0 0 20px rgba(0,0,0,0.5); }
        canvas { display: block; max-width: 100%; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        /* The Controls Area */
        .controls { width: 340px; background: #2a2a2a; padding: 20px; border-radius: 8px; }
        
        .grid-editor { 
            display: grid; 
            grid-template-columns: repeat(16, 1fr); /* 16 Cols */
            gap: 1px; 
            margin-top: 15px; 
            background: #444;
            border: 1px solid #555;
        }
        .grid-editor input { 
            width: 100%; 
            text-align: center; 
            background: #222; 
            color: #fff; 
            border: none; 
            font-size: 10px; 
            padding: 4px 0; 
            font-family: monospace;
        }
        .grid-editor input:focus { background: #555; outline: none; }
        
        .btn-group { display: flex; gap: 10px; margin-top: 15px; }
        button { flex: 1; padding: 12px; cursor: pointer; border: none; font-weight: bold; border-radius: 4px; transition: 0.2s; }
        #solveBtn { background: #28a745; color: white; }
        #solveBtn:hover { background: #218838; }
        #solveBtn:disabled { background: #555; cursor: not-allowed; }
        
        .status { margin-top: 15px; font-size: 0.9em; color: #ffd700; min-height: 1.2em; }
        
        .legend { margin-top: 20px; font-size: 0.8em; color: #888; }
        .legend span { display: inline-block; width: 12px; height: 12px; margin-right: 5px; vertical-align: middle; }
    </style>
</head>
<body>

    <h1>Sum-10 Optimizer</h1>
    <p>Paste Screenshot (Ctrl+V). Grid size: 10x16.</p>

    <div class="container">
        <!-- Image Display Area -->
        <div class="canvas-wrapper" id="canvasContainer" style="display:none;">
            <canvas id="gameCanvas"></canvas>
            <canvas id="overlayCanvas"></canvas>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div id="status" class="status">Waiting for image...</div>
            
            <div class="btn-group">
                <button id="solveBtn" onclick="solveGrid()" disabled>CALCULATE BEST MOVES</button>
            </div>

            <div class="legend">
                <div><span style="background:rgba(0, 255, 0, 0.6)"></span>Green: Best Moves (3+ numbers)</div>
                <div><span style="background:rgba(255, 165, 0, 0.5)"></span>Orange: Simple Moves (2 numbers)</div>
            </div>
            
            <h3 style="margin-top:20px; font-size:1em;">Manual Correction:</h3>
            <div id="gridEditor" class="grid-editor"></div>
        </div>
    </div>

<script>
    // --- CONFIGURATION ---
    const ROWS = 10;
    const COLS = 16;
    // ---------------------

    let gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    
    // Paste Event Listener
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => processImage(img);
            }
        }
    });

    async function processImage(img) {
        document.getElementById('status').innerText = "Initializing Processor...";
        document.getElementById('canvasContainer').style.display = "block";

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlayCanvas');
        
        // Resize canvas to match image
        canvas.width = img.width;
        canvas.height = img.height;
        overlay.width = img.width;
        overlay.height = img.height;
        
        ctx.drawImage(img, 0, 0);

        const cellW = img.width / COLS;
        const cellH = img.height / ROWS;

        document.getElementById('status').innerText = "Scanning Grid... (Please wait)";
        document.getElementById('solveBtn').disabled = true;
        
        // Setup Tesseract
        const worker = await Tesseract.createWorker('eng');
        await worker.setParameters({
            tessedit_char_whitelist: '0123456789',
            tessedit_pageseg_mode: Tesseract.PSM.SINGLE_CHAR,
        });

        // Setup Editor UI
        const editor = document.getElementById('gridEditor');
        editor.innerHTML = ''; 
        let processedCount = 0;
        const total = ROWS * COLS;

        // --- SCANNING LOOP ---
        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                
                // Prepare small canvas for this specific cell
                const cellCanvas = document.createElement('canvas');
                cellCanvas.width = cellW;
                cellCanvas.height = cellH;
                const cCtx = cellCanvas.getContext('2d');
                
                // Crop with padding to ignore grid lines
                const padX = cellW * 0.20; 
                const padY = cellH * 0.20;
                
                cCtx.drawImage(canvas, 
                    (c * cellW) + padX, (r * cellH) + padY, 
                    cellW - (padX*2), cellH - (padY*2), 
                    0, 0, cellW, cellH
                );

                // Create Input Field
                const input = document.createElement('input');
                input.id = `cell-${r}-${c}`;
                input.type = "text";
                // Update gridData if user types manually
                input.oninput = function() { 
                    let val = parseInt(this.value);
                    if(isNaN(val)) val = 0;
                    gridData[r][c] = val; 
                };
                editor.appendChild(input);

                // Perform OCR
                const { data: { text } } = await worker.recognize(cellCanvas);
                
                // Parse result
                let num = parseInt(text.trim());
                if(isNaN(num)) num = 0; // Blank or error becomes 0
                
                gridData[r][c] = num;
                input.value = num === 0 ? '' : num;

                // Update UI status every 5 cells
                processedCount++;
                if(processedCount % 5 === 0) {
                    const percent = Math.round((processedCount/total)*100);
                    document.getElementById('status').innerText = `Scanning: ${percent}%`;
                }
            }
        }
        
        await worker.terminate();
        document.getElementById('status').innerText = "Scan Complete. Verify numbers & Solve.";
        document.getElementById('solveBtn').disabled = false;
    }

    function solveGrid() {
        let allMatches = [];
        
        // 1. FIND ALL POSSIBLE VALID RECTANGLES
        for (let r1 = 0; r1 < ROWS; r1++) {
            for (let c1 = 0; c1 < COLS; c1++) {
                // Expanding to bottom-right
                for (let r2 = r1; r2 < ROWS; r2++) {
                    for (let c2 = c1; c2 < COLS; c2++) {
                        
                        let sum = 0;
                        let cellCount = 0; // Non-zero numbers involved
                        
                        for (let i = r1; i <= r2; i++) {
                            for (let j = c1; j <= c2; j++) {
                                let val = gridData[i][j];
                                sum += val;
                                if(val > 0) cellCount++;
                            }
                        }

                        // VALID MATCH FOUND
                        if (sum === 10 && cellCount > 0) {
                            allMatches.push({ 
                                r1, c1, r2, c2, 
                                cellCount, 
                                area: (r2-r1+1)*(c2-c1+1) 
                            });
                        }
                    }
                }
            }
        }

        // 2. SORT MATCHES TO FIND "THE BEST"
        // Priority 1: High Count (3+ numbers is better than 2)
        // Priority 2: Area (Compact is usually easier to read, but let's go for larger area to clear more blanks)
        allMatches.sort((a, b) => {
            if (b.cellCount !== a.cellCount) return b.cellCount - a.cellCount;
            return b.area - a.area;
        });

        // 3. SELECT NON-OVERLAPPING SET (Greedy Algorithm)
        // We want to give the user a plan to clear as much as possible in one go.
        let finalMoves = [];
        let occupied = new Set(); // Stores "r,c" keys

        for (let m of allMatches) {
            let clash = false;
            
            // Check if this match overlaps with a move we already picked
            for (let i = m.r1; i <= m.r2; i++) {
                for (let j = m.c1; j <= m.c2; j++) {
                    if (occupied.has(`${i},${j}`)) {
                        clash = true;
                        break;
                    }
                }
                if(clash) break;
            }

            // If no clash, add to our battle plan
            if (!clash) {
                finalMoves.push(m);
                // Mark cells as occupied
                for (let i = m.r1; i <= m.r2; i++) {
                    for (let j = m.c1; j <= m.c2; j++) {
                        occupied.add(`${i},${j}`);
                    }
                }
            }
        }

        drawSolutions(finalMoves);
    }

    function drawSolutions(matches) {
        const overlay = document.getElementById('overlayCanvas');
        const ctx = overlay.getContext('2d');
        const width = overlay.width;
        const height = overlay.height;
        const cellW = width / COLS;
        const cellH = height / ROWS;

        // Clear previous drawings
        ctx.clearRect(0, 0, width, height);

        if (matches.length === 0) {
            document.getElementById('status').innerText = "No matches found!";
            return;
        }

        let totalCleared = 0;

        matches.forEach((m, index) => {
            totalCleared += m.cellCount;

            const x = m.c1 * cellW;
            const y = m.r1 * cellH;
            const w = (m.c2 - m.c1 + 1) * cellW;
            const h = (m.r2 - m.r1 + 1) * cellH;

            // Color Coding
            // Green for High Score moves (3+ numbers), Orange for basic moves
            if (m.cellCount >= 3) {
                ctx.fillStyle = 'rgba(0, 255, 0, 0.4)'; // Green
                ctx.strokeStyle = '#00ff00';
            } else {
                ctx.fillStyle = 'rgba(255, 165, 0, 0.5)'; // Orange
                ctx.strokeStyle = '#ffa500';
            }
            
            ctx.lineWidth = 3;
            ctx.fillRect(x, y, w, h);
            ctx.strokeRect(x, y, w, h);
            
            // Draw Number Label
            ctx.fillStyle = "white";
            ctx.font = "bold 16px sans-serif";
            ctx.shadowColor="black";
            ctx.shadowBlur=4;
            ctx.fillText(index + 1, x + 5, y + 20);
        });

        document.getElementById('status').innerText = `Found ${matches.length} moves. Clears ${totalCleared} numbers!`;
    }
</script>
</body>
</html>
