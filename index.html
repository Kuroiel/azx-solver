<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arima Kinen</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #2979ff; --gold: #ffd740; --green: #00e676; --error: #ff1744; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: #e0e0e0; display: flex; flex-direction: column; align-items: center; padding: 20px; height: 100vh; margin: 0; }
        
        .layout { display: flex; flex-direction: row-reverse; gap: 20px; flex-wrap: wrap-reverse; justify-content: center; align-items: flex-start; width: 100%; max-width: 1200px; }
        
        .stage { 
            position: relative; 
            border: 3px dashed #444; 
            background: #080808; 
            cursor: crosshair; 
            min-width: 400px; 
            min-height: 300px; 
            display: flex; 
            justify-content: center; 
            align-items: center;
            outline: none;
        }
        .stage:focus { border-color: var(--accent); }
        
        canvas { display: block; image-rendering: pixelated; max-width: 100%; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        .placeholder-text { pointer-events: none; color: #555; font-size: 1.5em; font-weight: bold; text-align: center; }
        
        .panel { width: 300px; background: var(--panel); padding: 20px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.5); display: flex; flex-direction: column; }
        .status { font-weight: bold; margin-bottom: 15px; color: var(--accent); min-height: 1.2em; font-size: 0.9em; border-bottom: 1px solid #333; padding-bottom: 10px; }
        
        .btn { width: 100%; padding: 25px; border: none; border-radius: 6px; font-weight: bold; font-size: 20px; cursor: pointer; background: #333; color: #777; transition: 0.1s; margin-top: 10px;}
        .btn.active { background: var(--green); color: #000; box-shadow: 0 0 20px rgba(0, 230, 118, 0.3); animation: pulse 1.5s infinite; }
        .btn:active { transform: translateY(2px); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; animation: none; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

        .slider-box { margin: 15px 0; padding: 10px; background: #2a2a2a; border-radius: 4px; border: 1px solid #333; }
        .slider-header { display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa; margin-bottom: 5px; }

        .info-text { font-size: 0.8em; color: #aaa; margin-top: 20px; text-align: center; line-height: 1.5; }
        .warning { color: var(--error); font-weight: bold; }

        .tooltip { position: absolute; background: rgba(0,0,0,0.95); padding: 15px; border: 1px solid #fff; border-radius: 6px; pointer-events: none; display: none; transform: translate(-50%, -100%); margin-top: -15px; text-align: center; z-index: 100; box-shadow: 0 5px 15px black;}
        .tooltip-img { width: 48px; height: 48px; border: 1px solid #555; display: block; margin: 0 auto 10px; image-rendering: pixelated; }
    </style>
</head>
<body>

    <h2 style="color:var(--accent); margin-top:0;">Arima Kinen</h2>
    
    <div class="layout">
        <div class="stage" id="stageContainer" tabindex="0">
            <div id="placeholder" class="placeholder-text">CLICK HERE<br><span style="font-size:0.6em">CTRL+V</span></div>
            <canvas id="mainCanvas" style="display:none"></canvas>
            <canvas id="overlayCanvas"></canvas>
            <div id="correctionTooltip" class="tooltip">
                <canvas id="tooltipCanvas" class="tooltip-img"></canvas>
                <div id="tooltipText">Type Correct Number</div>
            </div>
        </div>

        <div class="panel">
            <div id="status" class="status">Waiting for image...</div>

            <div class="slider-box">
                <div class="slider-header"><span>Contrast Filter</span> <span id="threshVal">140</span></div>
                <input type="range" id="threshold" min="80" max="220" value="140" style="width:100%" oninput="process()">
            </div>

            <button id="solveBtn" class="btn" disabled onclick="applyMove()">MOVE DONE</button>
            
            <div class="info-text">
                <b>Missing a number?</b><br>
                Click the empty spot on the grid.<br>
                Type the number.<br>
                The solver will update instantly.
            </div>
            
            <div style="margin-top:auto; text-align:center; font-size:0.7em; color:#555; cursor:pointer;" onclick="resetMem()">
                [ Clear Learned Data ]
            </div>
        </div>
    </div>

<script>
    // --- CONFIG ---
    const ROWS = 15;
    const COLS = 10;
    const NORM_SIZE = 16;
    
    const ASCII_DIGITS = {
        1: ["  #  "," ##  ","  #  ","  #  ","  #  ","  #  "," ### "],
        2: [" ### ","#   #","    #","   # ","  #  "," #   ","#####"],
        3: ["#####","    #","   # ","    #","    #","#   #"," ### "],
        4: ["   # ","  ## "," # # ","#  # ","#####","   # ","   # "],
        5: ["#####","#    ","#### ","    #","    #","#   #"," ### "],
        6: [" ### ","#    ","#    ","#### ","#   #","#   #"," ### "],
        7: ["#####","    #","   # ","  #  "," #   "," #   "," #   "],
        8: [" ### ","#   #"," ### ","#   #","#   #","#   #"," ### "],
        9: [" ### ","#   #","#   #"," ####","    #","   # "," ### "],
        0: [" ### ","#   #","#   #","#   #","#   #","#   #"," ### "]
    };

    let srcImg = null;
    let gridData = [];
    let blobs = [];
    let currentMove = null;
    let userMemory = JSON.parse(localStorage.getItem('sum10_pro_mem')) || [];
    let systemMemory = [];
    let gridMetrics = { minX:0, maxX:0, minY:0, maxY:0 };

    // --- INIT ---
    generateSystemMemory();
    
    document.addEventListener('paste', e => {
        e.preventDefault();
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                document.getElementById('status').innerText = "Processing...";
                img.onload = () => { 
                    srcImg = img; 
                    document.getElementById('placeholder').style.display = 'none';
                    document.getElementById('mainCanvas').style.display = 'block';
                    process(); 
                };
            }
        }
    });

    const stage = document.getElementById('stageContainer');
    const tooltip = document.getElementById('correctionTooltip');
    let correctionGridPos = null;
    let correctionTargetBlob = null;

    stage.addEventListener('click', () => stage.focus());

    // --- ENHANCED CLICK HANDLER ---
    stage.addEventListener('mousedown', e => {
        if(!srcImg || gridMetrics.maxX === 0) return;
        const rect = stage.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Map click to grid coordinates (Extrapolated)
        const tW = gridMetrics.maxX - gridMetrics.minX;
        const tH = gridMetrics.maxY - gridMetrics.minY;
        const stepX = tW / 9; 
        const stepY = tH / 14;

        // Use Math.round relative to the anchor point
        const c = Math.round((x - gridMetrics.minX) / stepX);
        const r = Math.round((y - gridMetrics.minY) / stepY);

        if(c>=0 && c<COLS && r>=0 && r<ROWS) {
            correctionGridPos = { r, c };
            
            tooltip.style.display = 'block';
            tooltip.style.left = x + 'px';
            tooltip.style.top = y + 'px';
            
            // Is there an existing blob?
            const b = blobs.find(b => b.gridR === r && b.gridC === c);
            const tc = document.getElementById('tooltipCanvas');
            const txt = document.getElementById('tooltipText');
            
            if(b) {
                // Yes, editing existing detection
                correctionTargetBlob = b;
                tc.style.display = "block";
                tc.width = NORM_SIZE; tc.height = NORM_SIZE;
                const tctx = tc.getContext('2d');
                const img = tctx.createImageData(NORM_SIZE, NORM_SIZE);
                for(let i=0; i<b.feature.length; i++) {
                    const v = b.feature[i]*255;
                    img.data[i*4]=v; img.data[i*4+1]=v; img.data[i*4+2]=v; img.data[i*4+3]=255;
                }
                tctx.putImageData(img,0,0);
                txt.innerText = "Correct this Number (1-9)";
            } else {
                // No, forcing a new number into empty/missed space
                correctionTargetBlob = null;
                tc.style.display = "none";
                txt.innerText = "Add Missing Number (1-9)";
            }
            e.stopPropagation();
        } else {
            tooltip.style.display = 'none';
        }
    });

    window.addEventListener('keydown', e => {
        if(correctionGridPos && e.key >= '0' && e.key <= '9') {
            const num = parseInt(e.key);
            const {r, c} = correctionGridPos;

            // 1. Update the logical grid
            gridData[r][c] = num;
            
            // 2. Handle visual blob
            if(correctionTargetBlob) {
                // We are correcting a real blob
                correctionTargetBlob.label = num;
                correctionTargetBlob.isGarbage = false;
                userMemory.push({ label: num, data: correctionTargetBlob.feature });
                localStorage.setItem('sum10_pro_mem', JSON.stringify(userMemory));
            } else {
                // We are injecting a VIRTUAL blob because scanner missed it
                const tW = gridMetrics.maxX - gridMetrics.minX;
                const tH = gridMetrics.maxY - gridMetrics.minY;
                const stepX = tW / 9; 
                const stepY = tH / 14;
                
                const cx = gridMetrics.minX + (c * stepX);
                const cy = gridMetrics.minY + (r * stepY);
                
                blobs.push({
                    x: cx-10, y: cy-10, w: 20, h: 20,
                    gridR: r, gridC: c,
                    label: num,
                    lowConf: false,
                    isVirtual: true // Marker for debugging
                });
            }
            
            tooltip.style.display = 'none';
            // Recalculate move without re-processing image (Fast Update)
            calculateStrategicMove();
            drawScene();
        }
    });

    // --- MAIN PIPELINE ---
    function process() {
        if(!srcImg) return;
        
        const thresh = parseInt(document.getElementById('threshold').value);
        document.getElementById('threshVal').innerText = thresh;

        const cvs = document.getElementById('mainCanvas');
        const ctx = cvs.getContext('2d');
        const ovl = document.getElementById('overlayCanvas');
        
        cvs.width = srcImg.width; cvs.height = srcImg.height;
        ovl.width = srcImg.width; ovl.height = srcImg.height;

        ctx.drawImage(srcImg, 0, 0);

        const raw = ctx.getImageData(0,0,cvs.width,cvs.height);
        
        // 1. Detect
        blobs = detectBlobs(raw, cvs.width, cvs.height, thresh);
        
        // 2. Map
        gridData = mapBlobsToGrid(blobs);

        // 3. Recognize
        blobs.forEach(b => {
            if(b.gridR === null) return;
            b.feature = extractFeature(ctx, b);
            
            let match = findBestMatch(b.feature, userMemory);
            if(!match) match = findBestMatch(b.feature, systemMemory, 50);

            if(match) {
                if(match.label !== -1) {
                    gridData[b.gridR][b.gridC] = match.label;
                    b.label = match.label;
                } else {
                    b.isGarbage = true;
                    gridData[b.gridR][b.gridC] = -1; 
                }
            } else {
                const forced = findBestMatch(b.feature, systemMemory, Infinity);
                gridData[b.gridR][b.gridC] = forced.label;
                b.label = forced.label;
                b.lowConf = true;
            }
        });

        // 4. Ghost Detection
        detectGhosts(ctx, thresh);

        calculateStrategicMove();
        drawScene();
    }

    // --- GHOST DETECTOR ---
    function detectGhosts(ctx, thresh) {
        if(gridMetrics.maxX === 0) return;

        const tW = gridMetrics.maxX - gridMetrics.minX;
        const tH = gridMetrics.maxY - gridMetrics.minY;
        const stepX = tW / 9; 
        const stepY = tH / 14;

        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                if(gridData[r][c] === 0) {
                    const cx = gridMetrics.minX + (c * stepX);
                    const cy = gridMetrics.minY + (r * stepY);
                    
                    if(cx<0 || cx>ctx.canvas.width || cy<0 || cy>ctx.canvas.height) continue;

                    const sample = ctx.getImageData(cx - 5, cy - 5, 10, 10).data;
                    let brightPixels = 0;
                    
                    for(let i=0; i<sample.length; i+=4) {
                        const b = (sample[i]+sample[i+1]+sample[i+2])/3;
                        if(b > thresh) brightPixels++;
                    }

                    if(brightPixels > 2) {
                        gridData[r][c] = -1; 
                    }
                }
            }
        }
    }

    // --- STRATEGY ENGINE ---
  // Configuration for the "Brain"
    const SEARCH_DEPTH = 3;  // Look 3 moves ahead (Increase to 4 for smarter but slower)
    const BEAM_WIDTH = 20;   // Keep track of the top 20 best paths

    function calculateStrategicMove() {
        const currentMoves = getAllMoves(gridData);
        
        if (currentMoves.length === 0) {
            currentMove = null;
            return;
        }

        // Initialize Search: Map all current valid moves to game states
        let currentStates = currentMoves.map(move => {
            const simGrid = cloneGrid(gridData);
            applyMoveToGrid(simGrid, move);
            return {
                grid: simGrid,
                totalScore: move.count,    // Total cleared in this path
                firstMove: move,           // The move we actually make right now
                maxSingle: move.count      // Track largest single move in this path
            };
        });

        // Loop forward to find the best future outcomes
        for (let d = 1; d < SEARCH_DEPTH; d++) {
            let nextStates = [];
            
            // Sort states so we only process the most promising ones (The Beam)
            // Priority: 1. Total Cleared, 2. Max Single Move size
            currentStates.sort((a, b) => {
                if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
                return b.maxSingle - a.maxSingle;
            });
            currentStates = currentStates.slice(0, BEAM_WIDTH);

            // Expand each promising state
            for (let state of currentStates) {
                const possibleNextMoves = getAllMoves(state.grid);
                
                if (possibleNextMoves.length === 0) {
                    nextStates.push(state); // Path ends here, keep it
                    continue;
                }

                // Only consider top 10 branches per state to keep speed high
                const candidates = possibleNextMoves.slice(0, 10);

                for (let nextMove of candidates) {
                    const nextGrid = cloneGrid(state.grid);
                    applyMoveToGrid(nextGrid, nextMove);

                    nextStates.push({
                        grid: nextGrid,
                        totalScore: state.totalScore + nextMove.count,
                        firstMove: state.firstMove, // Remember the move that started this chain
                        maxSingle: Math.max(state.maxSingle, nextMove.count)
                    });
                }
            }
            
            // If we found valid extensions, update our current list
            if (nextStates.length > 0) {
                currentStates = nextStates;
            } else {
                break; // No further moves possible anywhere
            }
        }

        // Final Sort to pick the winner
        currentStates.sort((a, b) => {
            if (b.totalScore !== a.totalScore) return b.totalScore - a.totalScore;
            return b.maxSingle - a.maxSingle;
        });

        const bestState = currentStates[0];
        currentMove = bestState.firstMove;
        
        // Update predictedNext so the UI shows how many points this path yields
        // Logic: (Total Path Score) - (Immediate Move Score)
        currentMove.predictedNext = bestState.totalScore - currentMove.count; 
    }

    function getAllMoves(grid) {
        let moves = [];
        const R = grid.length;
        const C = grid[0].length;

        for (let r1 = 0; r1 < R; r1++) {
            for (let c1 = 0; c1 < C; c1++) {
                // Optimization: Skip loop if starting cell is garbage
                if (grid[r1][c1] === -1) continue; 

                for (let r2 = r1; r2 < R; r2++) {
                    for (let c2 = c1; c2 < C; c2++) {
                        let sum = 0;
                        let count = 0;
                        let blocked = false;

                        // Calculate sum of the rectangle
                        calcLoop:
                        for(let i = r1; i <= r2; i++){
                            for(let j = c1; j <= c2; j++){
                                let v = grid[i][j];
                                if (v === -1) { blocked = true; break calcLoop; }
                                sum += v;
                                if(v > 0) count++;
                                
                                // Optimization: Stop immediately if sum exceeds 10
                                if (sum > 10) break calcLoop; 
                            }
                        }

                        if(!blocked && sum === 10 && count > 1) {
                            moves.push({
                                r1, c1, r2, c2, count,
                                area: (r2-r1+1)*(c2-c1+1)
                            });
                        }
                    }
                }
            }
        }
        // Initial sort by Count Descending (helps the Beam Search prune bad moves early)
        return moves.sort((a, b) => b.count - a.count);
    }

    // --- DRAWING ---
    function drawScene() {
        const cvs = document.getElementById('overlayCanvas');
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0,0,cvs.width,cvs.height);

        // Draw State of Grid
        if(gridMetrics.maxX > 0) {
            const tW = gridMetrics.maxX - gridMetrics.minX;
            const tH = gridMetrics.maxY - gridMetrics.minY;
            const stepX = tW / 9; 
            const stepY = tH / 14;

            for(let r=0; r<ROWS; r++) {
                for(let c=0; c<COLS; c++) {
                    const val = gridData[r][c];
                    const cx = gridMetrics.minX + (c * stepX);
                    const cy = gridMetrics.minY + (r * stepY);
                    const boxS = stepX * 0.8; 

                    if (val === 0) {
                        ctx.fillStyle = "rgba(0,0,0,0.8)";
                        ctx.fillRect(cx - boxS/2, cy - boxS/2, boxS, boxS);
                    } else if (val === -1) {
                        ctx.strokeStyle = "red";
                        ctx.lineWidth = 2;
                        ctx.strokeRect(cx - boxS/2, cy - boxS/2, boxS, boxS);
                        
                        ctx.beginPath();
                        ctx.moveTo(cx - boxS/2, cy - boxS/2);
                        ctx.lineTo(cx + boxS/2, cy + boxS/2);
                        ctx.moveTo(cx + boxS/2, cy - boxS/2);
                        ctx.lineTo(cx - boxS/2, cy + boxS/2);
                        ctx.stroke();
                    } 
                }
            }
        }

        blobs.forEach(b => {
            if (gridData[b.gridR][b.gridC] <= 0) return;

            const labelX = b.x - 2;
            const labelY = b.y - 12;
            const size = 14;

            ctx.fillStyle = b.lowConf ? "#ffd740" : "#69f0ae"; 
            ctx.beginPath();
            ctx.roundRect(labelX, labelY, size, size, 2);
            ctx.fill();

            ctx.font = "bold 11px Arial";
            ctx.fillStyle = "black";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(b.label, labelX + size/2, labelY + size/2 + 1);
        });

        const btn = document.getElementById('solveBtn');
        if(currentMove) {
            btn.disabled = false;
            btn.className = "btn active";
            
            let statusText = `Clears ${currentMove.count}`;
            if(currentMove.predictedNext > 0) statusText += ` (+${currentMove.predictedNext} next)`;
            
            btn.innerHTML = `MOVE DONE<br><span style="font-size:0.6em; font-weight:normal">${statusText}</span>`;
            document.getElementById('status').innerText = "Best Move Calculated.";

            // Recalc steps for highlight drawing
            const tW = gridMetrics.maxX - gridMetrics.minX;
            const tH = gridMetrics.maxY - gridMetrics.minY;
            const stepX = tW / 9; 
            const stepY = tH / 14;

            const x1 = gridMetrics.minX + (currentMove.c1 * stepX) - (stepX/2);
            const y1 = gridMetrics.minY + (currentMove.r1 * stepY) - (stepY/2);
            const x2 = gridMetrics.minX + (currentMove.c2 * stepX) + (stepX/2); 
            const y2 = gridMetrics.minY + (currentMove.r2 * stepY) + (stepY/2);
            
            const rectW = x2 - x1;
            const rectH = y2 - y1;

            const pad = 2;
            ctx.strokeStyle = "#00e676"; 
            ctx.lineWidth = 4;
            ctx.strokeRect(x1+pad, y1+pad, rectW-pad*2, rectH-pad*2);
            ctx.fillStyle = "rgba(105, 240, 174, 0.25)";
            ctx.fillRect(x1+pad, y1+pad, rectW-pad*2, rectH-pad*2);

        } else {
            btn.disabled = true;
            btn.className = "btn";
            btn.innerHTML = "NO MOVES";
            document.getElementById('status').innerText = "Board cleared or stuck.";
        }
    }

    function applyMove() {
        if(!currentMove) return;
        applyMoveToGrid(gridData, currentMove);
        calculateStrategicMove();
        drawScene();
    }

    // --- HELPERS ---
    function detectBlobs(imgData, w, h, t) {
        const d=imgData.data, v=new Uint8Array(w*h), res=[];
        for(let i=0; i<w*h; i+=2) {
            if(v[i])continue;
            if((d[i*4]+d[i*4+1]+d[i*4+2])/3 > t) {
                let s=[i], minX=w, maxX=0, minY=h, maxY=0; v[i]=1;
                while(s.length){
                    const c=s.pop(), cx=c%w, cy=Math.floor(c/w);
                    if(cx<minX)minX=cx; if(cx>maxX)maxX=cx; if(cy<minY)minY=cy; if(cy>maxY)maxY=cy;
                    [c+1,c-1,c+w,c-w].forEach(n=>{
                        if(n>=0 && n<w*h && !v[n] && (d[n*4]+d[n*4+1]+d[n*4+2])/3 > t){v[n]=1;s.push(n);}
                    });
                }
                const width=maxX-minX+1, height=maxY-minY+1;
                if(width>3 && height>6 && width<60 && height<60) res.push({x:minX, y:minY, w:width, h:height});
            }
        }
        return res;
    }

    function extractFeature(ctx, b) {
        const c=document.createElement('canvas'); c.width=NORM_SIZE; c.height=NORM_SIZE;
        const x=c.getContext('2d'); x.drawImage(ctx.canvas,b.x,b.y,b.w,b.h,0,0,NORM_SIZE,NORM_SIZE);
        const d=x.getImageData(0,0,NORM_SIZE,NORM_SIZE).data, a=[];
        for(let i=0; i<d.length; i+=4) a.push(d[i]>100?1:0);
        return a;
    }

    function findBestMatch(f, lib, maxErr=30) {
        let best=null, min=Infinity;
        lib.forEach(l=>{
            let e=0; for(let i=0;i<256;i++)if(f[i]!==l.data[i])e++;
            if(e<min){min=e; best=l;}
        });
        return min<=maxErr ? best : null;
    }

    function mapBlobsToGrid(blobs) {
        let g=Array(ROWS).fill().map(()=>Array(COLS).fill(0));
        if(!blobs.length) return g;
        
        const xs = blobs.map(b=>b.x).sort((a,b)=>a-b);
        const ys = blobs.map(b=>b.y).sort((a,b)=>a-b);
        const qMinX = xs[Math.floor(xs.length*0.02)];
        const qMaxX = xs[Math.floor(xs.length*0.98)] + 20; 
        const qMinY = ys[Math.floor(ys.length*0.02)];
        const qMaxY = ys[Math.floor(ys.length*0.98)] + 20;

        let minX=9999, maxX=0, minY=9999, maxY=0;
        blobs.forEach(b=>{
            if(b.x >= qMinX && b.x <= qMaxX && b.y >= qMinY && b.y <= qMaxY) {
                if(b.x<minX)minX=b.x; if(b.x+b.w>maxX)maxX=b.x+b.w;
                if(b.y<minY)minY=b.y; if(b.y+b.h>maxY)maxY=b.y+b.h;
            }
        });

        gridMetrics = { minX, maxX, minY, maxY };

        const tW=maxX-minX;
        const tH=maxY-minY;
        const stepX = tW / 9; 
        const stepY = tH / 14;

        blobs.forEach(b => {
            if(b.x < minX || b.x > maxX || b.y < minY || b.y > maxY) {
                b.gridR = null; return; 
            }
            const cx = b.x + b.w/2;
            const cy = b.y + b.h/2;
            const c = Math.round((cx - minX) / stepX);
            const r = Math.round((cy - minY) / stepY);
            
            if(c>=0 && c<COLS && r>=0 && r<ROWS) {
                b.gridR=r; b.gridC=c; 
            } else {
                b.gridR=null; 
            }
        });
        return g;
    }

    function cloneGrid(grid) { return grid.map(r => [...r]); }

    function applyMoveToGrid(grid, move) {
        for(let r=move.r1; r<=move.r2; r++) {
            for(let c=move.c1; c<=move.c2; c++) {
                grid[r][c] = 0;
            }
        }
    }

    function generateSystemMemory() {
        for(let n in ASCII_DIGITS) {
            const art=ASCII_DIGITS[n], f=new Array(256).fill(0);
            for(let r=0;r<16;r++) for(let c=0;c<16;c++) {
                const ar=Math.floor(r/(16/7)), ac=Math.floor(c/(16/5));
                if(art[ar] && art[ar][ac]==='#') f[r*16+c]=1;
            }
            systemMemory.push({label:parseInt(n), data:f});
        }
    }

    function resetMem() {
        if(confirm("Clear memory?")) { localStorage.removeItem('sum10_pro_mem'); userMemory=[]; process(); }
    }
</script>
</body>
</html>
