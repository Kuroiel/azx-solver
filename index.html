<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sum-10 Grid Solver</title>
    <!-- Load Tesseract.js for OCR -->
    <script src='https://cdn.jsdelivr.net/npm/tesseract.js@5/dist/tesseract.min.js'></script>
    <style>
        body { font-family: sans-serif; background: #222; color: #fff; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        h1 { margin-bottom: 10px; }
        .container { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; }
        .canvas-wrapper { position: relative; border: 2px solid #555; }
        canvas { display: block; max-width: 100%; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        .controls { width: 300px; display: flex; flex-direction: column; gap: 10px; }
        .grid-editor { display: grid; grid-template-columns: repeat(15, 1fr); gap: 2px; margin-top: 20px; }
        .grid-editor input { width: 100%; text-align: center; background: #333; color: white; border: 1px solid #444; font-size: 10px; padding: 2px 0; }
        
        button { padding: 10px; cursor: pointer; background: #007bff; color: white; border: none; font-size: 16px; border-radius: 4px; }
        button:hover { background: #0056b3; }
        button:disabled { background: #555; cursor: not-allowed; }
        
        .status { margin-top: 10px; font-style: italic; color: #aaa; }
    </style>
</head>
<body>

    <h1>Sum-10 Solver</h1>
    <p>Paste your screenshot (Ctrl+V) anywhere on this page. Try to crop just the grid.</p>

    <div class="container">
        <!-- Image Display Area -->
        <div class="canvas-wrapper" id="canvasContainer" style="display:none;">
            <canvas id="gameCanvas"></canvas>
            <canvas id="overlayCanvas"></canvas>
        </div>

        <!-- Controls -->
        <div class="controls">
            <div id="status" class="status">Waiting for image...</div>
            <button id="solveBtn" onclick="solveGrid()" disabled>Solve</button>
            
            <h3>Verify Numbers:</h3>
            <div id="gridEditor" class="grid-editor"></div>
        </div>
    </div>

<script>
    const ROWS = 9;
    const COLS = 15;
    let gridData = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    
    // Paste Event Listener
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => processImage(img);
            }
        }
    });

    async function processImage(img) {
        document.getElementById('status').innerText = "Processing image...";
        document.getElementById('canvasContainer').style.display = "block";

        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const overlay = document.getElementById('overlayCanvas');
        
        // Resize canvas to match image
        canvas.width = img.width;
        canvas.height = img.height;
        overlay.width = img.width;
        overlay.height = img.height;
        
        ctx.drawImage(img, 0, 0);

        // Calculate cell size
        const cellW = img.width / COLS;
        const cellH = img.height / ROWS;

        document.getElementById('status').innerText = "Reading numbers (this takes a moment)...";
        document.getElementById('solveBtn').disabled = true;

        // Perform OCR
        // We will try to read the whole image and hope Tesseract respects lines, 
        // OR we chop it up. Chopping is more accurate for grids.
        
        const worker = await Tesseract.createWorker('eng');
        await worker.setParameters({
            tessedit_char_whitelist: '0123456789', // Only look for numbers
            tessedit_pageseg_mode: Tesseract.PSM.SINGLE_CHAR, // Treat as single characters if we loop
        });

        // Loop through grid and read specific spots
        // Note: Doing 135 individual OCR calls is slow. 
        // For a quick helper, we'll try a hybrid: Assume perfect grid, extract image data.
        
        let processedCount = 0;
        const total = ROWS * COLS;
        const editor = document.getElementById('gridEditor');
        editor.innerHTML = ''; // Clear previous

        for (let r = 0; r < ROWS; r++) {
            for (let c = 0; c < COLS; c++) {
                // Crop individual cell
                const cellCanvas = document.createElement('canvas');
                cellCanvas.width = cellW;
                cellCanvas.height = cellH;
                const cCtx = cellCanvas.getContext('2d');
                
                // Add a little padding to remove grid lines
                const padX = cellW * 0.15;
                const padY = cellH * 0.15;
                
                cCtx.drawImage(canvas, 
                    (c * cellW) + padX, (r * cellH) + padY, 
                    cellW - (padX*2), cellH - (padY*2), 
                    0, 0, cellW, cellH
                );

                // Create input for editor
                const input = document.createElement('input');
                input.id = `cell-${r}-${c}`;
                input.type = "text";
                input.onchange = () => { gridData[r][c] = parseInt(input.value) || 0; };
                editor.appendChild(input);

                // Run OCR on this small chunk
                const { data: { text } } = await worker.recognize(cellCanvas);
                const num = parseInt(text.trim()) || 0; // Default to 0 (blank) if failed
                
                gridData[r][c] = num;
                input.value = num === 0 ? '' : num;

                processedCount++;
                if(processedCount % 5 === 0) {
                    document.getElementById('status').innerText = `Reading... ${Math.round((processedCount/total)*100)}%`;
                }
            }
        }
        
        await worker.terminate();
        document.getElementById('status').innerText = "Ready! Check numbers below and click Solve.";
        document.getElementById('solveBtn').disabled = false;
    }

    function solveGrid() {
        const matches = [];
        
        // Brute force all rectangles
        for (let r1 = 0; r1 < ROWS; r1++) {
            for (let c1 = 0; c1 < COLS; c1++) {
                for (let r2 = r1; r2 < ROWS; r2++) {
                    for (let c2 = c1; c2 < COLS; c2++) {
                        
                        let sum = 0;
                        let cellCount = 0;
                        
                        // Sum the rectangle
                        for (let i = r1; i <= r2; i++) {
                            for (let j = c1; j <= c2; j++) {
                                sum += gridData[i][j];
                                if(gridData[i][j] > 0) cellCount++;
                            }
                        }

                        if (sum === 10 && cellCount > 0) {
                            // Calculate area score (bigger is better)
                            matches.push({ r1, c1, r2, c2, area: (r2-r1+1)*(c2-c1+1), cellCount });
                        }
                    }
                }
            }
        }

        drawSolutions(matches);
    }

    function drawSolutions(matches) {
        const overlay = document.getElementById('overlayCanvas');
        const ctx = overlay.getContext('2d');
        const width = overlay.width;
        const height = overlay.height;
        const cellW = width / COLS;
        const cellH = height / ROWS;

        ctx.clearRect(0, 0, width, height);

        // Sort matches by area (largest first) to draw them first
        // Or strictly show the "Best" ones. 
        // Let's filter to only show the top 10 largest matches to avoid clutter
        matches.sort((a, b) => b.cellCount - a.cellCount);
        const topMatches = matches.slice(0, 15); // Show top 15

        if (topMatches.length === 0) {
            alert("No matches found that equal 10!");
            return;
        }

        topMatches.forEach((m, index) => {
            const x = m.c1 * cellW;
            const y = m.r1 * cellH;
            const w = (m.c2 - m.c1 + 1) * cellW;
            const h = (m.r2 - m.r1 + 1) * cellH;

            // Cycle colors
            const colors = ['rgba(0, 255, 0, 0.4)', 'rgba(255, 255, 0, 0.4)', 'rgba(0, 255, 255, 0.4)'];
            ctx.fillStyle = colors[index % colors.length];
            ctx.strokeStyle = 'white';
            ctx.lineWidth = 2;

            ctx.fillRect(x, y, w, h);
            ctx.strokeRect(x, y, w, h);
            
            // Draw order number
            ctx.fillStyle = "white";
            ctx.font = "bold 20px Arial";
            ctx.fillText(`#${index+1}`, x + 5, y + 20);
        });

        document.getElementById('status').innerText = `Found ${matches.length} matches. Showing top ${topMatches.length}.`;
    }
</script>
</body>
</html>
