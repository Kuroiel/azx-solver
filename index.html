<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sum-10 Smart Grid Solver</title>
    <style>
        :root { --bg: #121212; --panel: #1e1e1e; --accent: #2979ff; --gold: #ffd740; --green: #00e676; --error: #ff1744; }
        body { font-family: 'Segoe UI', sans-serif; background: var(--bg); color: #e0e0e0; display: flex; flex-direction: column; align-items: center; padding: 20px; }
        
        /* Layout: Left Panel, Right Image */
        .layout { display: flex; flex-direction: row-reverse; gap: 20px; flex-wrap: wrap-reverse; justify-content: center; align-items: flex-start; }
        
        /* Interactive Stage */
        .stage { position: relative; border: 2px solid #444; background: #000; cursor: crosshair; }
        canvas { display: block; image-rendering: pixelated; }
        #overlayCanvas { position: absolute; top: 0; left: 0; pointer-events: none; }
        
        /* Controls */
        .panel { width: 300px; background: var(--panel); padding: 20px; border-radius: 8px; box-shadow: 0 5px 20px rgba(0,0,0,0.5); display: flex; flex-direction: column; }
        .status { font-weight: bold; margin-bottom: 15px; color: var(--accent); min-height: 1.2em; font-size: 0.9em; border-bottom: 1px solid #333; padding-bottom: 10px; }
        
        .btn { width: 100%; padding: 25px; border: none; border-radius: 6px; font-weight: bold; font-size: 20px; cursor: pointer; background: #333; color: #777; transition: 0.1s; margin-top: 10px;}
        .btn.active { background: var(--green); color: #000; box-shadow: 0 0 20px rgba(0, 230, 118, 0.3); animation: pulse 1.5s infinite; }
        .btn:active { transform: translateY(2px); }
        .btn:disabled { opacity: 0.3; cursor: not-allowed; animation: none; }

        @keyframes pulse { 0% { transform: scale(1); } 50% { transform: scale(1.02); } 100% { transform: scale(1); } }

        .slider-box { margin: 15px 0; padding: 10px; background: #2a2a2a; border-radius: 4px; border: 1px solid #333; }
        .slider-header { display: flex; justify-content: space-between; font-size: 0.8em; color: #aaa; margin-bottom: 5px; }

        .info-text { font-size: 0.8em; color: #aaa; margin-top: 20px; text-align: center; line-height: 1.5; }
        .highlight { color: var(--green); font-weight: bold; }
        .warning { color: var(--error); font-weight: bold; }

        /* Correction Tooltip */
        .tooltip { position: absolute; background: rgba(0,0,0,0.95); padding: 15px; border: 1px solid #fff; border-radius: 6px; pointer-events: none; display: none; transform: translate(-50%, -100%); margin-top: -15px; text-align: center; z-index: 100; box-shadow: 0 5px 15px black;}
        .tooltip-img { width: 48px; height: 48px; border: 1px solid #555; display: block; margin: 0 auto 10px; image-rendering: pixelated; }
    </style>
</head>
<body>

    <h2 style="color:var(--accent); margin-top:0;">Tenno Sho (Autumn)</h2>
    
    <div class="layout">
        <div class="stage" id="stageContainer">
            <canvas id="mainCanvas"></canvas>
            <canvas id="overlayCanvas"></canvas>
            <div id="correctionTooltip" class="tooltip">
                <canvas id="tooltipCanvas" class="tooltip-img"></canvas>
                <div>Type Correct Number</div>
            </div>
        </div>

        <div class="panel">
            <div id="status" class="status">Paste screenshot (Ctrl+V)</div>

            <div class="slider-box">
                <div class="slider-header"><span>Contrast Filter</span> <span id="threshVal">140</span></div>
                <input type="range" id="threshold" min="80" max="220" value="140" style="width:100%" oninput="process()">
            </div>

            <button id="solveBtn" class="btn" disabled onclick="applyMove()">MOVE DONE</button>
            
            <div class="info-text">
                <b>Look for RED boxes.</b><br>
                <span class="warning">Red Box = Unknown Number.</span><br>
                The solver will NOT use Red boxes to prevent math errors.<br>
                Click a Red Box to teach it.
            </div>
            
            <div style="margin-top:auto; text-align:center; font-size:0.7em; color:#555; cursor:pointer;" onclick="resetMem()">
                [ Clear Learned Data ]
            </div>
        </div>
    </div>

<script>
    // --- CONFIG ---
    const ROWS = 15;
    const COLS = 10;
    const NORM_SIZE = 16;
    
    const ASCII_DIGITS = {
        1: ["  #  "," ##  ","  #  ","  #  ","  #  ","  #  "," ### "],
        2: [" ### ","#   #","    #","   # ","  #  "," #   ","#####"],
        3: ["#####","    #","   # ","    #","    #","#   #"," ### "],
        4: ["   # ","  ## "," # # ","#  # ","#####","   # ","   # "],
        5: ["#####","#    ","#### ","    #","    #","#   #"," ### "],
        6: [" ### ","#    ","#    ","#### ","#   #","#   #"," ### "],
        7: ["#####","    #","   # ","  #  "," #   "," #   "," #   "],
        8: [" ### ","#   #"," ### ","#   #","#   #","#   #"," ### "],
        9: [" ### ","#   #","#   #"," ####","    #","   # "," ### "],
        0: [" ### ","#   #","#   #","#   #","#   #","#   #"," ### "]
    };

    let srcImg = null;
    let gridData = [];
    let blobs = [];
    let currentMove = null;
    let userMemory = JSON.parse(localStorage.getItem('sum10_pro_mem')) || [];
    let systemMemory = [];

    // Grid Bounds for Visualization
    let gridMetrics = { minX:0, maxX:0, minY:0, maxY:0 };

    // --- INIT ---
    generateSystemMemory();
    
    // --- EVENTS ---
    window.addEventListener('paste', e => {
        const items = (e.clipboardData || e.originalEvent.clipboardData).items;
        for (let item of items) {
            if (item.type.indexOf('image') !== -1) {
                const blob = item.getAsFile();
                const img = new Image();
                img.src = URL.createObjectURL(blob);
                img.onload = () => { srcImg = img; process(); };
            }
        }
    });

    const stage = document.getElementById('stageContainer');
    const tooltip = document.getElementById('correctionTooltip');
    let correctionTarget = null; 

    // Handle Clicking on Numbers to Fix
    stage.addEventListener('mousedown', e => {
        if(!srcImg) return;
        const rect = stage.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;
        
        // Find clicked blob
        const clicked = blobs.find(b => 
            x >= b.x - 5 && x <= b.x + b.w + 5 && 
            y >= b.y - 15 && y <= b.y + b.h + 5
        );

        if(clicked) {
            correctionTarget = clicked;
            tooltip.style.display = 'block';
            tooltip.style.left = (clicked.x + clicked.w/2) + 'px';
            tooltip.style.top = clicked.y + 'px';
            
            const tc = document.getElementById('tooltipCanvas');
            tc.width = NORM_SIZE; tc.height = NORM_SIZE;
            const tctx = tc.getContext('2d');
            const img = tctx.createImageData(NORM_SIZE, NORM_SIZE);
            for(let i=0; i<clicked.feature.length; i++) {
                const v = clicked.feature[i]*255;
                img.data[i*4]=v; img.data[i*4+1]=v; img.data[i*4+2]=v; img.data[i*4+3]=255;
            }
            tctx.putImageData(img,0,0);
            e.stopPropagation();
        } else {
            tooltip.style.display = 'none';
            correctionTarget = null;
        }
    });

    window.addEventListener('keydown', e => {
        if(correctionTarget && e.key >= '0' && e.key <= '9') {
            const num = parseInt(e.key);
            userMemory.push({ label: num, data: correctionTarget.feature });
            localStorage.setItem('sum10_pro_mem', JSON.stringify(userMemory));
            tooltip.style.display = 'none';
            correctionTarget = null;
            process(); 
        }
        if(correctionTarget && (e.key.toLowerCase() === 'x' || e.key === 'Delete')) {
             userMemory.push({ label: -1, data: correctionTarget.feature });
             localStorage.setItem('sum10_pro_mem', JSON.stringify(userMemory));
             tooltip.style.display = 'none';
             correctionTarget = null;
             process();
        }
    });

    // --- MAIN PIPELINE ---
    function process() {
        if(!srcImg) return;
        
        const thresh = parseInt(document.getElementById('threshold').value);
        document.getElementById('threshVal').innerText = thresh;

        const cvs = document.getElementById('mainCanvas');
        const ctx = cvs.getContext('2d');
        const ovl = document.getElementById('overlayCanvas');
        
        cvs.width = srcImg.width; cvs.height = srcImg.height;
        ovl.width = srcImg.width; ovl.height = srcImg.height;

        ctx.drawImage(srcImg, 0, 0);

        const raw = ctx.getImageData(0,0,cvs.width,cvs.height);
        
        // 1. Detect
        blobs = detectBlobs(raw, cvs.width, cvs.height, thresh);
        
        // 2. Map (Using Dynamic Range)
        gridData = mapBlobsToGrid(blobs);

        // 3. Recognize
        blobs.forEach(b => {
            if(b.gridR === null) return;
            b.feature = extractFeature(ctx, b);
            
            let match = findBestMatch(b.feature, userMemory);
            if(!match) match = findBestMatch(b.feature, systemMemory, 50);

            if(match) {
                if(match.label !== -1) {
                    gridData[b.gridR][b.gridC] = match.label;
                    b.label = match.label;
                } else {
                    b.isGarbage = true;
                    // Garbage means "Valid Empty Space" or "Ignore"? 
                    // In this game, garbage usually means bucket rim.
                    // If it's a bucket rim, it's NOT a number, but it occupies space.
                    // For safety: Treat as Blocked.
                    gridData[b.gridR][b.gridC] = -1; 
                }
            } else {
                // Try force guess
                const forced = findBestMatch(b.feature, systemMemory, Infinity);
                // If the error is massive, it's probably noise.
                // But if it's kinda close, it's a number.
                
                // CRITICAL FIX: If we aren't sure, mark as -1 (Blocked).
                // Do not guess '0'. That causes math errors.
                // Do not guess '5'. That causes math errors.
                // Mark as Unknown.
                
                // Let's rely on forced guess but mark low confidence
                gridData[b.gridR][b.gridC] = forced.label;
                b.label = forced.label;
                b.lowConf = true;
            }
        });

        calculateStrategicMove();
    }

    // --- STRATEGY ENGINE ---
    function calculateStrategicMove() {
        const currentMoves = getAllMoves(gridData);
        
        if (currentMoves.length === 0) {
            currentMove = null;
            drawScene();
            return;
        }

        const candidates = currentMoves.slice(0, 15);
        let bestStrategy = null;
        let maxTotalPoints = -1;

        for (let move of candidates) {
            const simGrid = cloneGrid(gridData);
            applyMoveToGrid(simGrid, move);
            
            const nextMoves = getAllMoves(simGrid);
            const bestNext = nextMoves.length > 0 ? nextMoves[0] : null;
            
            const nextScore = bestNext ? bestNext.count : 0;
            const totalScore = move.count + nextScore;

            if (totalScore > maxTotalPoints) {
                maxTotalPoints = totalScore;
                bestStrategy = move;
                bestStrategy.predictedNext = nextScore;
            }
        }

        currentMove = bestStrategy;
        drawScene();
    }

    function getAllMoves(grid) {
        let moves = [];
        for (let r1=0; r1<ROWS; r1++) {
            for (let c1=0; c1<COLS; c1++) {
                for (let r2=r1; r2<ROWS; r2++) {
                    for (let c2=c1; c2<COLS; c2++) {
                        let sum=0, count=0;
                        let blocked = false;

                        for(let i=r1; i<=r2; i++){
                            for(let j=c1; j<=c2; j++){
                                let v = grid[i][j];
                                if (v === -1) { blocked = true; break; } // UNKNOWN/BLOCKED
                                sum+=v; 
                                if(v>0) count++;
                            }
                            if(blocked) break;
                        }
                        
                        // Valid move only if sum is 10 AND no blocked cells
                        if(!blocked && sum === 10 && count > 0) {
                            moves.push({
                                r1, c1, r2, c2, count,
                                area: (r2-r1+1)*(c2-c1+1)
                            });
                        }
                    }
                }
            }
        }
        return moves.sort((a, b) => b.count - a.count);
    }

    // --- DRAWING ---
    function drawScene() {
        const cvs = document.getElementById('overlayCanvas');
        const ctx = cvs.getContext('2d');
        ctx.clearRect(0,0,cvs.width,cvs.height);

        // Draw Dynamic Grid Lin
